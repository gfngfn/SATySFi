use open Basic
use Option

module List :> sig
  type t 'a = list 'a
  val ~lift 'a : ('a -> code 'a) -> list 'a -> code (list 'a)
  val persistent ~compare 'a : ('a -> 'a -> ordering) -> list 'a -> list 'a -> ordering
  val persistent ~equal 'a : ('a -> 'a -> bool) -> list 'a -> list 'a -> bool
  val persistent ~show 'a : ('a -> string) -> list 'a -> string
  val persistent ~fold 'a 'b : ('a -> 'b -> 'a) -> 'a -> list 'b -> 'a
  val persistent ~fold-indexed 'a 'b : ('a -> int -> 'b -> 'a) -> 'a -> list 'b -> 'a
  val persistent ~fold-back 'a 'b : ('a -> 'b -> 'b) -> list 'a -> 'b -> 'b
  val persistent ~fold-adjacent 'a 'b : ('a -> 'b -> option 'b -> option 'b -> 'a) -> 'a -> list 'b -> 'a
  val persistent ~fold-indexed-adjacent 'a 'b : ('a -> int -> 'b -> option 'b -> option 'b -> 'a) -> 'a -> list 'b -> 'a
  val persistent ~reverse 'a : list 'a -> list 'a
  val persistent ~map 'a 'b : ('a -> 'b) -> list 'a -> list 'b
  val persistent ~map-indexed 'a 'b : (int -> 'a -> 'b) -> list 'a -> list 'b
  val persistent ~map-adjacent 'a 'b : ('a -> option 'a -> option 'a -> 'b) -> list 'a -> list 'b
  val persistent ~map-indexed-adjacent 'a 'b : (int -> 'a -> option 'a -> option 'a -> 'b) -> list 'a -> list 'b
  val persistent ~map-with-ends 'a 'b : (bool -> bool -> 'a -> 'b) -> list 'a -> list 'b
  val persistent ~append 'a : list 'a -> list 'a -> list 'a
  val persistent ~concat 'a : list (list 'a) -> list 'a
  val persistent ~pure 'a : 'a -> list 'a
  val persistent ~bind 'a 'b : list 'a -> ('a -> list 'b) -> list 'b
  val persistent ~iter 'a : ('a -> unit) -> list 'a -> unit
  val persistent ~iter-indexed 'a : (int -> 'a -> unit) -> list 'a -> unit
  val persistent ~filter 'a : ('a -> bool) -> list 'a -> list 'a
  val persistent ~filter-map 'a 'b : ('a -> option 'b) -> list 'a -> list 'b
  val persistent ~find 'a : ('a -> bool) -> list 'a -> option 'a
  val persistent ~find-map 'a 'b : ('a -> option 'b) -> list 'a -> option 'b
  val persistent ~length 'a : list 'a -> int
  val persistent ~nth 'a : int -> list 'a -> option 'a
  val persistent ~is-empty 'a : list 'a -> bool
end = struct

  type t 'a = list 'a

  val ~rec lift lf xs =
    match xs with
    | []      -> &[]
    | x :: xs -> &(~(lf x) :: ~(lift lf xs))
    end

  val persistent ~rec compare comp xs1 xs2 =
    match (xs1, xs2) with
    | ([], []) ->
        Equal
    | (x1 :: ys1, x2 :: ys2) ->
        match comp x1 x2 with
        | Equal -> compare comp ys1 ys2
        | other -> other
        end
    | ([], _ :: _) ->
        Less
    | (_ :: _, []) ->
        Greater
    end

  val persistent ~rec equal eq xs1 xs2 =
    match (xs1, xs2) with
    | ([], [])               -> true
    | (x1 :: ys1, x2 :: ys2) -> if eq x1 x2 then equal eq ys1 ys2 else false
    | _                      -> false
    end

  val persistent ~show sh =
    let rec aux xs =
      match xs with
      | []      -> ` `
      | [x]     -> sh x
      | x :: ys -> sh x ^ `, `# ^ aux ys
      end
    in
    (fun xs -> `[` ^ aux xs ^ `]`)

  val persistent ~rec fold f acc ys =
    match ys with
    | []      -> acc
    | x :: xs -> fold f (f acc x) xs
    end

  val persistent ~fold-indexed f =
    let rec aux i f acc ys =
      match ys with
      | []      -> acc
      | x :: xs -> aux (i + 1) f (f acc i x) xs
      end
    in
    aux 0 f

  val persistent ~rec fold-back f ys acc =
    match ys with
    | []      -> acc
    | x :: xs -> f x (fold-back f xs acc)
    end

  val persistent ~fold-adjacent f =
    let rec aux prev-opt acc xs =
      match xs with
      | [] ->
          acc
      | head :: [] ->
          f acc head prev-opt None
      | head :: ((right :: _) as tail) ->
          let acc-new = f acc head prev-opt (Some(right)) in
          aux (Some(head)) acc-new tail
      end
    in
    aux None

  val persistent ~fold-indexed-adjacent f init xs =
    let (_, acc) =
      xs |> fold-adjacent (fun (i, acc) x prev-opt next-opt -> (
        (i + 1, f acc i x prev-opt next-opt)
      )) (0, init)
    in
    acc

  val persistent ~reverse xs =
    fold (fun acc x -> x :: acc) [] xs

  val persistent ~rec map f ys =
    match ys with
    | []      -> []
    | x :: xs -> (f x) :: map f xs
    end

  val persistent ~map-indexed f =
    let rec aux i f ys =
      match ys with
      | []      -> []
      | x :: xs -> (f i x) :: aux (i + 1) f xs
      end
    in
    aux 0 f

  val persistent ~map-adjacent f xs =
    xs |> fold-adjacent (fun acc x prev-opt next-opt -> (
      f x prev-opt next-opt :: acc
    )) [] |> reverse

  val persistent ~map-indexed-adjacent f xs =
    xs |> fold-indexed-adjacent (fun acc i x prev-opt next-opt -> (
      f i x prev-opt next-opt :: acc
    )) [] |> reverse

  val persistent ~map-with-ends f xs =
    fold-adjacent (fun acc x prev-opt next-opt -> (
      let is-first = Option.is-none prev-opt in
      let is-last = Option.is-none next-opt in
      let y = f is-first is-last x in
      y :: acc
    )) [] xs |> reverse

  val persistent ~rec append xs1 xs2 =
    match xs1 with
    | []      -> xs2
    | x :: xs -> x :: append xs xs2
    end

  val persistent ~concat xs =
    fold-back append xs []

  val persistent ~pure x =
    [x]

  val persistent ~bind xs f =
    concat (map f xs)

  val persistent ~rec iter f ys =
    match ys with
    | []      -> ()
    | x :: xs -> let () = f x in iter f xs
    end

  val persistent ~iter-indexed f =
    let rec aux i f ys =
      match ys with
      | []      -> ()
      | x :: xs -> let () = f i x in aux (i + 1) f xs
      end
    in
    aux 0 f

  val persistent ~rec filter p ys =
    match ys with
    | []      -> []
    | x :: xs -> if p x then x :: filter p xs else filter p xs
    end

  val persistent ~rec filter-map f ys =
    match ys with
    | [] ->
        []
    | x :: xs ->
        match f x with
        | None    -> filter-map f xs
        | Some(v) -> v :: filter-map f xs
        end
    end

  val persistent ~rec find p ys =
    match ys with
    | []      -> None
    | x :: xs -> if p x then Some(x) else find p ys
    end

  val persistent ~find-map f =
    let rec aux ys =
      match ys with
      | [] ->
          None
      | x :: xs ->
          match f x with
          | Some(v) -> Some(v)
          | None    -> aux xs
          end
      end
    in
    aux

  val persistent ~length xs =
    fold (fun i _ -> i + 1) 0 xs

  val persistent ~nth n =
    let rec aux i ys =
      match ys with
      | []      -> None
      | x :: xs -> if i == n then Some(x) else aux (i + 1) xs
      end
    in
    aux 0

  val persistent ~is-empty xs =
    match xs with
    | []     -> true
    | _ :: _ -> false
    end

end
