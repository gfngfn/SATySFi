use Basic
use Int
use Float
use String
use Ordering
use Option
use List
use Pair
use Map
use Set
use Length
use Vector
use Point
use Logo
use Inline
use Block
use Context
use Ref
use Color
use Path
use Graphics
use PaperSize
use Deco
use HDecoSet
use VDecoSet
use CrossRef

module Stdlib :> sig
  % Basic
  type ordering = Less | Equal | Greater
  type vector = length * length
  type point = length * length
  type paren = length -> length -> context -> inline-boxes * (length -> length)
  type paddings = length * length * length * length
  signature Ord = sig
    type t :: o
    val compare : t -> t -> ordering
  end
  module Int : sig
    type t = int
    val ~lift : int -> code int
    val persistent ~compare : int -> int -> ordering
    val persistent ~equal : int -> int -> bool
    val persistent ~abs : int -> int
    val persistent ~max : int -> int -> int
    val persistent ~min : int -> int -> int
  end
  module Float : sig
    type t = float
    val ~lift : float -> code float
    val persistent ~abs : float -> float
    val persistent ~max : float -> float -> float
    val persistent ~min : float -> float -> float
    val persistent ~pi : float
  end
  module String : sig
    type t = string
    val ~lift : string -> code string
    val persistent ~compare : string -> string -> ordering
    val persistent ~equal : string -> string -> bool
    val persistent ~append : string -> string -> string
    val persistent ~length : string -> int
    val persistent ~byte-length : string -> int
    val persistent ~sub : string -> int -> int -> string
    val persistent ~sub-bytes : string -> int -> int -> string
    val persistent ~to-scalar-values : string -> list int
    val persistent ~from-scalar-values : list int -> string
    val persistent ~normalize-to-nfc : string -> string
    val persistent ~normalize-to-nfd : string -> string
    val persistent ~split-into-grapheme-clusters : string -> list string
    val persistent ~empty : string
    val persistent ~split-into-lines : string -> list (int * string)
    val persistent ~concat : string -> list string -> string
    val persistent ~chop-prefix : string -> string -> option string
    val persistent ~chop-suffix : string -> string -> option string
  end
  module Ordering : sig
    type t = ordering
    val ~lift : ordering -> code ordering
    val persistent ~compare : ordering -> ordering -> ordering
    val persistent ~equal : ordering -> ordering -> bool
    val persistent ~show : ordering -> string
  end
  module Option : sig
    type t 'a = option 'a
    val ~lift 'a : ('a -> code 'a) -> option 'a -> code (option 'a)
    val persistent ~compare 'a : ('a -> 'a -> ordering) -> option 'a -> option 'a -> ordering
    val persistent ~equal 'a : ('a -> 'a -> bool) -> option 'a -> option 'a -> bool
    val persistent ~map 'a 'b : ('a -> 'b) -> option 'a -> option 'b
    val persistent ~pure 'a : 'a -> option 'a
    val persistent ~bind 'a 'b : option 'a -> ('a -> option 'b) -> option 'b
    val persistent ~from 'a : 'a -> option 'a -> 'a
    val persistent ~is-none 'a : option 'a -> bool
  end
  module List : sig
    type t 'a = list 'a
    val ~lift 'a : ('a -> code 'a) -> list 'a -> code (list 'a)
    val persistent ~compare 'a : ('a -> 'a -> ordering) -> list 'a -> list 'a -> ordering
    val persistent ~equal 'a : ('a -> 'a -> bool) -> list 'a -> list 'a -> bool
    val persistent ~show 'a : ('a -> string) -> list 'a -> string
    val persistent ~fold 'a 'b : ('a -> 'b -> 'a) -> 'a -> list 'b -> 'a
    val persistent ~fold-indexed 'a 'b : ('a -> int -> 'b -> 'a) -> 'a -> list 'b -> 'a
    val persistent ~fold-back 'a 'b : ('a -> 'b -> 'b) -> list 'a -> 'b -> 'b
    val persistent ~fold-adjacent 'a 'b : ('a -> 'b -> option 'b -> option 'b -> 'a) -> 'a -> list 'b -> 'a
    val persistent ~fold-indexed-adjacent 'a 'b : ('a -> int -> 'b -> option 'b -> option 'b -> 'a) -> 'a -> list 'b -> 'a
    val persistent ~reverse 'a : list 'a -> list 'a
    val persistent ~map 'a 'b : ('a -> 'b) -> list 'a -> list 'b
    val persistent ~map-indexed 'a 'b : (int -> 'a -> 'b) -> list 'a -> list 'b
    val persistent ~map-with-ends 'a 'b : (bool -> bool -> 'a -> 'b) -> list 'a -> list 'b
    val persistent ~map-adjacent 'a 'b : ('a -> option 'a -> option 'a -> 'b) -> list 'a -> list 'b
    val persistent ~map-indexed-adjacent 'a 'b : (int -> 'a -> option 'a -> option 'a -> 'b) -> list 'a -> list 'b
    val persistent ~append 'a : list 'a -> list 'a -> list 'a
    val persistent ~concat 'a : list (list 'a) -> list 'a
    val persistent ~pure 'a : 'a -> list 'a
    val persistent ~bind 'a 'b : list 'a -> ('a -> list 'b) -> list 'b
    val persistent ~iter 'a : ('a -> unit) -> list 'a -> unit
    val persistent ~iter-indexed 'a : (int -> 'a -> unit) -> list 'a -> unit
    val persistent ~filter 'a : ('a -> bool) -> list 'a -> list 'a
    val persistent ~filter-map 'a 'b : ('a -> option 'b) -> list 'a -> list 'b
    val persistent ~find 'a : ('a -> bool) -> list 'a -> option 'a
    val persistent ~find-map 'a 'b : ('a -> option 'b) -> list 'a -> option 'b
    val persistent ~length 'a : list 'a -> int
    val persistent ~nth 'a : int -> list 'a -> option 'a
    val persistent ~is-empty 'a : list 'a -> bool
  end
  module Pair : sig
    val ~lift 'a 'b : ('a -> code 'a) -> ('b -> code 'b) -> 'a * 'b -> code ('a * 'b)
    val persistent ~compare 'a 'b : ('a -> 'a -> ordering) -> ('b -> 'b -> ordering) -> 'a * 'b -> 'a * 'b -> ordering
    val persistent ~equal 'a 'b : ('a -> 'a -> bool) -> ('b -> 'b -> bool) -> 'a * 'b -> 'a * 'b -> bool
    val persistent ~show 'a 'b : ('a -> string) -> ('b -> string) -> 'a * 'b -> string
    val persistent ~first 'a 'b : 'a * 'b -> 'a
    val persistent ~second 'a 'b : 'a * 'b -> 'b
    val persistent ~map-first 'a1 'a2 'b : ('a1 -> 'a2) -> 'a1 * 'b -> 'a2 * 'b
    val persistent ~map-second 'a 'b1 'b2 : ('b1 -> 'b2) -> 'a * 'b1 -> 'a * 'b2
  end
  module Map : sig
    module Make : (Key : Ord) -> sig
      type t :: o -> o
      val empty 'v : t 'v
      val singleton 'v : Key.t -> 'v -> t 'v
      val add 'v : Key.t -> 'v -> t 'v -> t 'v
      val remove 'v : Key.t -> t 'v -> t 'v
      val find 'v : Key.t -> t 'v -> option 'v
      val map 'u 'v : ('u -> 'v) -> t 'u -> t 'v
      val map-with-key 'u 'v : (Key.t -> 'u -> 'v) -> t 'u -> t 'v
      val fold 'a 'v : ('a -> Key.t -> 'v -> 'a) -> 'a -> t 'v -> 'a
      val fold-back 'a 'v : ('a -> Key.t -> 'v -> 'a) -> 'a -> t 'v -> 'a
      val to-list 'v : t 'v -> list (Key.t * 'v)
      val to-list-reversed 'v : t 'v -> list (Key.t * 'v)
      val from-list 'v : list (Key.t * 'v) -> t 'v
    end
  end
  module Set : sig
    module Make : (Elem : Ord) -> sig
      type t :: o
      val empty : t
      val add : Elem.t -> t -> t
      val remove : Elem.t -> t -> t
      val is-member : Elem.t -> t -> bool
      val fold 'a : ('a -> Elem.t -> 'a) -> 'a -> t -> 'a
      val fold-back 'a : ('a -> Elem.t -> 'a) -> 'a -> t -> 'a
      val to-list : t -> list Elem.t
      val to-list-reversed : t -> list Elem.t
      val from-list : list Elem.t -> t
    end
  end
  module Length : sig
    type t = length
    val ~lift : length -> code length
    val persistent ~max : length -> length -> length
    val persistent ~min : length -> length -> length
    val persistent ~abs : length -> length
    val persistent ~atan2 : length -> length -> float
  end
  module Vector : sig
    type t = vector
    val ~lift : vector -> code vector
    val persistent ~get-x : vector -> length
    val persistent ~get-y : vector -> length
    val persistent ~scale : float -> vector -> vector
    val persistent ~add : vector -> vector -> vector
    val persistent ~subtract : vector -> vector -> vector
    val persistent ~length : vector -> length
  end
  module Point : sig
    type t = point
    val ~lift : point -> code point
    val persistent ~get-x : point -> length
    val persistent ~get-y : point -> length
    val persistent ~add : point -> vector -> point
    val persistent ~subtract : point -> point -> vector
    val persistent ~atan2 : point -> point -> float
    val persistent ~dividing-point : float -> point -> point -> point
  end
  module Logo : sig
    val \SATySFi : inline []
    val \LaTeX : inline []
    val \TeX : inline []
  end
  module Inline : sig
    val nil : inline-boxes
    val concat : list inline-boxes -> inline-boxes
    val fil : inline-boxes
    val get-natural-metrics : inline-boxes -> length * length * length
    val get-natural-advance : inline-boxes -> length
    val skip : length -> inline-boxes
    val kern : length -> inline-boxes
    val glue : length -> length -> length -> inline-boxes
    val frame-inner : paddings -> deco -> inline-boxes -> inline-boxes
    val frame-outer : paddings -> deco -> inline-boxes -> inline-boxes
    val frame-fixed : length -> paddings -> deco -> inline-boxes -> inline-boxes
    val frame-breakable : paddings -> deco-set -> inline-boxes -> inline-boxes
    val embed-block-breakable : context -> block-boxes -> inline-boxes
    val graphics-fixed : length -> length -> length -> (point -> graphics) -> inline-boxes
    val graphics-outer : length -> length -> (length -> point -> graphics) -> inline-boxes
    val embed-block-top : context -> length -> (context -> block-boxes) -> inline-boxes
    val embed-block-bottom : context -> length -> (context -> block-boxes) -> inline-boxes
    val line-stack-top : list inline-boxes -> inline-boxes
    val line-stack-bottom : list inline-boxes -> inline-boxes
    val embed-string : string -> inline-text
    val embed-math : context -> math-boxes -> inline-boxes
    val no-break : inline-boxes -> inline-boxes
    val mandatory-break : context -> inline-boxes
    val omit-skip-after : inline-boxes
    val \skip : inline [length]
    val \no-break : inline [inline-text]
    val \fil : inline []
    val \fil-both : inline []
    val \mandatory-break : inline []
  end
  module Block : sig
    val nil : block-boxes
    val concat : list block-boxes -> block-boxes
    val clear-page : block-boxes
    val skip : length -> block-boxes
    val line-break : bool -> bool -> context -> inline-boxes -> block-boxes
    val form-paragraph : context -> inline-boxes -> block-boxes
    val +skip : block [length]
    val +clear-page : block []
    val +ragged-right : block [inline-text]
    val +centering : block [inline-text]
    val \skip : inline [length]
  end
  module Context : sig
    val initial : length -> inline [math-text] -> context
    val set-math-command : inline [math-text] -> context -> context
    val set-code-text-command : inline [string] -> context -> context
    val set-hyphenation-dictionary : hyphenation -> context -> context
    val set-unicode-char-database : unicode-char-database -> context -> context
    val set-hyphen-min : int -> int -> context -> context
    val set-min-gap-of-lines : length -> context -> context
    val set-space-ratio : float -> float -> float -> context -> context
    val set-adjacent-stretch-ratio : float -> context -> context
    val get-math-axis-height-ratio : context -> float
    val set-paragraph-margin : length -> length -> context -> context
    val set-min-paragraph-ascender-and-descender : length -> length -> context -> context
    val set-font-size : length -> context -> context
    val get-font-size : context -> length
    val set-text-color : color -> context -> context
    val get-text-color : context -> color
    val set-leading : length -> context -> context
    val get-text-width : context -> length
    val set-manual-rising : length -> context -> context
    val set-hyphen-penalty : int -> context -> context
    val set-math-variant-char : int -> (math-char-class -> int) -> context -> context
    val set-math-char : int -> int -> math-class -> context -> context
    val set-math-char-class : math-char-class -> context -> context
    val get-math-char-class : context -> math-char-class
    val set-word-break-penalty : int -> context -> context
    val set-every-word-break : inline-boxes -> inline-boxes -> context -> context
    val get-every-word-break : context -> inline-boxes * inline-boxes
  end
  module Ref : sig
    val persistent ~increment : ref int -> unit
    val persistent ~decrement : ref int -> unit
  end
  module Color : sig
    val gray   : float -> color
    val rgb    : float -> float -> float -> color
    val black  : color
    val white  : color
    val red    : color
    val yellow : color
    val orange : color
    val blue   : color

    % web color names
    val brown   : color
    val cyan    : color
    val green   : color
    val magenta : color
    val pink    : color
    val purple  : color
  end
  module Path : sig
    val rectangle : point -> point -> path
    val rectangle-round : length -> point -> point -> path
    val rectangle-round-left : length -> point -> point -> path
    val rectangle-round-left-lower : length -> point -> point -> path
    val rectangle-round-left-upper : length -> point -> point -> path
    val rectangle-round-right : length -> point -> point -> path
    val poly-line : point -> list point -> path
    val polygon : point -> list point -> path
    val line : point -> point -> path
    val circle : point -> length -> path
    val linear-transform : float -> float -> float -> float -> path -> path
    val shift : length * length -> path -> path
    val rotate : point -> float -> path -> path
    val scale : point -> float -> float -> path -> path
    val get-bounding-box : path -> point * point
  end
  module Graphics : sig
    val overlay : list graphics -> graphics
    val shift : length * length -> graphics -> graphics
    val linear-transform : float -> float -> float -> float -> graphics -> graphics
    val rotate : point -> float -> graphics -> graphics
    val scale : point -> float -> float -> graphics -> graphics
    val empty : graphics
    val text-centering : point -> inline-boxes -> graphics
    val text-leftward : point -> inline-boxes -> graphics
    val text-rightward : point -> inline-boxes -> graphics
    val arrow : length -> color -> length -> length -> length -> point -> point -> graphics
    val dashed-arrow : length -> length * length * length -> color -> length -> length -> length -> point -> point -> graphics
  end
  module PaperSize : sig
    val persistent ~a0 : length * length
    val persistent ~a1 : length * length
    val persistent ~a2 : length * length
    val persistent ~a3 : length * length
    val persistent ~a4 : length * length
    val persistent ~a5 : length * length
    val persistent ~a6 : length * length
    val persistent ~a7 : length * length
    val persistent ~a8 : length * length
    val persistent ~a9 : length * length
    val persistent ~a10 : length * length

    val persistent ~us-letter : length * length
    val persistent ~us-legal : length * length
  end
  module Deco : sig
    val empty : deco
    val simple-frame : length -> color -> color -> deco
  end
  module HDecoSet : sig
    val empty : deco-set
    val simple-frame-stroke : length -> color -> deco-set
    val rectangle-round-fill : length -> length -> color -> deco-set
  end
  module VDecoSet : sig
    val empty : deco-set
    val simple-frame-stroke : length -> color -> deco-set
    val simple-frame : length -> color -> color -> deco-set
    val paper : deco-set
    val quote-round : length -> length -> color -> deco-set
  end
  module CrossRef : sig
    type key = string
    type data = string
    val register : key -> data -> unit
    val get : key -> option data
    val probe : key -> option data
  end
end = struct
  include Basic
  module Int = Int
  module Float = Float
  module String = String
  module Ordering = Ordering
  module Option = Option
  module List = List
  module Pair = Pair
  module Map = Map
  module Set = Set
  module Length = Length
  module Vector = Vector
  module Point = Point
  module Logo = Logo
  module Inline = Inline
  module Block = Block
  module Context = Context
  module Ref = Ref
  module Color = Color
  module Path = Path
  module Graphics = Graphics
  module PaperSize = PaperSize
  module Deco = Deco
  module HDecoSet = HDecoSet
  module VDecoSet = VDecoSet
  module CrossRef = CrossRef
end
