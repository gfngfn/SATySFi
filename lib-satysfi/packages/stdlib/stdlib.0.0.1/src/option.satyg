use open Basic

module Option :> sig
  type t 'a = option 'a
  val ~lift 'a : ('a -> code 'a) -> option 'a -> code (option 'a)
  val persistent ~compare 'a : ('a -> 'a -> ordering) -> option 'a -> option 'a -> ordering
  val persistent ~equal 'a : ('a -> 'a -> bool) -> option 'a -> option 'a -> bool
  val persistent ~map 'a 'b : ('a -> 'b) -> option 'a -> option 'b
  val persistent ~pure 'a : 'a -> option 'a
  val persistent ~bind 'a 'b : option 'a -> ('a -> option 'b) -> option 'b
  val persistent ~from 'a : 'a -> option 'a -> 'a
  val persistent ~is-none 'a : option 'a -> bool
end = struct

  type t 'a = option 'a

  val ~lift lf opt =
    match opt with
    | None    -> &(None)
    | Some(v) -> &(Some(~(lf v)))
    end

  val persistent ~compare comp opt1 opt2 =
    match (opt1, opt2) with
    | (None, None)         -> Equal
    | (None, Some(_))      -> Less
    | (Some(_), None)      -> Greater
    | (Some(v1), Some(v2)) -> comp v1 v2
    end

  val persistent ~equal eq opt1 opt2 =
    match (opt1, opt2) with
    | (None, None)         -> true
    | (Some(v1), Some(v2)) -> eq v1 v2
    | _                    -> false
    end

  val persistent ~map f opt =
    match opt with
    | None    -> None
    | Some(v) -> Some(f v)
    end

  val persistent ~pure v =
    Some(v)

  val persistent ~bind opt f =
    match opt with
    | None    -> None
    | Some(v) -> f v
    end

  val persistent ~from a opt =
    match opt with
    | None    -> a
    | Some(v) -> v
    end

  val persistent ~is-none opt =
    match opt with
    | None    -> true
    | Some(_) -> false
    end

end
