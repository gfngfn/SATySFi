use package open Stdlib
use package Math
use package Code
use package Itemize
use package Annot

use package FontJunicode
use package FontIpaEx
use package FontLatinModern
use package FontLatinModernMath

module MDJa :> sig
  val document : (|
    title  : inline-text,
    author : inline-text,
  |) -> block-text -> document

  val +h1 : block [inline-text, block-text]
  val +h2 : block [inline-text, block-text]
  val +h3 : block [inline-text, block-text]
  val +h4 : block [inline-text, block-text]
  val +p : block [inline-text]
  val +ul-block : block [list block-text]
  val +ol-block : block [list block-text]
  val +code : block [string, string]
  val +quote : block [block-text]
  val +hr : block []

  val \code : inline [string]
  val \emph : inline [inline-text]
  val \strong : inline [inline-text]
  val \link : inline [string, inline-text]
  val \reference : inline [string, string, option (string * string)]
  val \img : inline [string, string, string]
  val \hard-break : inline []
end = struct

  val paper = PaperSize.a4
  val text-origin = (80pt, 100pt)
  val text-width = 440pt
  val text-height = 630pt
  val footer-origin = (40pt, 780pt)

  val skip-before-content = 20pt

  val font-size-main = 12pt
  val font-size-title = 20pt
  val font-size-h1 = 18pt
  val font-size-h2 = 16pt
  val font-size-h3 = 14pt
  val font-size-h4 = 12.5pt

  val font-ratio-cjk = 0.88

  val font-latin-roman  = (FontJunicode.normal, 1., 0.)
  val font-latin-italic = (FontJunicode.italic, 1., 0.)
  val font-latin-sans   = (FontLatinModern.sans, 1., 0.)
  val font-latin-mono   = (FontLatinModern.mono, 1., 0.)

  val font-cjk-gothic = (FontIpaEx.gothic, font-ratio-cjk, 0.)
  val font-cjk-mincho = (FontIpaEx.mincho, font-ratio-cjk, 0.)

  val hr-margin = 5mm
  val hr-thickness = 1pt

  val code-background = Gray(0.875)

  val text-color-link = RGB(0.0, 0.5, 1.0)


  val mutable h1-number <- 0
  val mutable h2-number <- 0
  val mutable h3-number <- 0
  val mutable h4-number <- 0
  val mutable h5-number <- 0
  val mutable h6-number <- 0
  val mutable reference-acc <- []


  val set-latin-font font ctx =
    ctx |> set-font Latin font


  val set-cjk-font font ctx =
    ctx |> set-font Kana font
        |> set-font HanIdeographic font


  val initial-context =
    get-initial-context text-width (command \Math.math)
      |> set-dominant-narrow-script Latin
      |> set-dominant-wide-script Kana
      |> set-latin-font font-latin-roman
      |> set-cjk-font font-cjk-mincho
      |> set-font OtherScript font-latin-roman
      |> set-hyphen-penalty 1000
      |> set-space-ratio 0.275 0.08 0.12


  val footer pbinfo =
    let it-nombre = embed-string (arabic pbinfo#page-number) in
    let ctx = initial-context in
    line-break true true ctx
      (inline-fil ++ read-inline ctx {— #it-nombre; —} ++ inline-fil)


  val make-title-context ctx =
    ctx |> set-font-size font-size-title
        |> set-latin-font font-latin-roman
        |> set-cjk-font font-cjk-mincho


  val pads-zero = (0pt, 0pt, 0pt, 0pt)


  val inline ctx \link url it =
    inline-frame-breakable pads-zero (Annot.link-to-uri-frame url None)
      (read-inline (ctx |> set-text-color text-color-link) it)


  val inline ctx \jump key-pdf-loc it =
    inline-frame-breakable pads-zero (Annot.link-to-location-frame key-pdf-loc None)
      (read-inline (ctx |> set-text-color text-color-link) it)


  val set-heading-font size ctx =
    ctx |> set-latin-font font-latin-sans
        |> set-cjk-font font-cjk-gothic
        |> set-font-size size


  val h1-heading = set-heading-font font-size-h1
  val h2-heading = set-heading-font font-size-h2
  val h3-heading = set-heading-font font-size-h3
  val h4-heading = set-heading-font font-size-h4


  val document rcd bt =
    let ctx = initial-context in
    let bb-title =
      let ctx = ctx |> make-title-context in
      line-break true true ctx
        (inline-fil ++ read-inline ctx rcd#title ++ inline-fil)
    in
    let bb-author =
      line-break true true ctx
        (inline-fil ++ read-inline ctx rcd#author)
    in
    let bb-main = read-block ctx bt in
    let bb-reference =
      match List.reverse !reference-acc with
      | [] ->
          block-nil

      | refs ->
          let bb-body =
            refs |> List.map (fun (tag, title, url) -> (
              let it-tag = embed-string tag in
              let it-title = embed-string title in
              let it = {[#it-tag;] \link(url){#it-title;}} in
              let key-pdf-loc = `reference:` ^ tag in
              let decoset = Annot.register-location-frame key-pdf-loc in
              let ib = inline-frame-breakable pads-zero decoset (read-inline ctx it) in
              line-break true true ctx (ib ++ inline-fil)
            )) |> List.fold-left (+++) block-nil
          in
          let bb-heading =
            let ctx = ctx |> h1-heading in
            line-break true false ctx (read-inline ctx {参考文献} ++ inline-fil)
          in
          bb-heading +++ bb-body
      end
    in
    let pagecontf _ =
      (|
        text-origin = text-origin,
        text-height = text-height,
      |)
    in
    let pagepartsf pbinfo =
      (|
        header-origin  = (0pt, 0pt),
        header-content = block-nil,
        footer-origin  = footer-origin,
        footer-content = footer pbinfo,
      |)
    in
    page-break paper pagecontf pagepartsf
      (List.fold-left (+++) block-nil [
        bb-title, bb-author,
        block-skip skip-before-content,
        bb-main,
        bb-reference,
      ])


  val increment-counter counter counter-children =
    let () = counter <- !counter + 1 in
    counter-children |> List.iter (fun r -> (r <- 0))


  val heading-scheme ctx bb-title bt =
    let bb-content = read-block ctx bt in
    bb-title +++ bb-content


  val block ctx +h1 it bt =
    let () = increment-counter h1-number [h2-number, h3-number, h4-number, h5-number, h6-number] in
    let bb-title =
      let s-num = arabic !h1-number in
      let it-num = embed-string s-num in
      let ctx = ctx |> h1-heading in
      line-break true false ctx
        (read-inline ctx {#it-num;. #it;} ++ inline-fil)
    in
    heading-scheme ctx bb-title bt


  val block ctx +h2 it bt =
    let () = increment-counter h2-number [h3-number, h4-number, h5-number, h6-number] in
    let bb-title =
      let s-num = arabic !h1-number ^ `.` ^ arabic !h2-number in
      let it-num = embed-string s-num in
      let ctx = ctx |> h2-heading in
      line-break true false ctx
        (read-inline ctx {#it-num;. #it;} ++ inline-fil)
    in
    heading-scheme ctx bb-title bt


  val block ctx +h3 it bt =
    let () = increment-counter h3-number [h4-number, h5-number, h6-number] in
    let bb-title =
      let s-num = arabic !h1-number ^ `.` ^ arabic !h2-number ^ `.` ^ arabic !h3-number in
      let it-num = embed-string s-num in
      let ctx = ctx |> h3-heading in
      line-break true false ctx
        (read-inline ctx {#it-num;. #it;} ++ inline-fil)
    in
    heading-scheme ctx bb-title bt


  val block ctx +h4 it bt =
    let bb-title =
      let s-num = arabic !h1-number ^ `.` ^ arabic !h2-number ^ `.` ^ arabic !h3-number ^ `.` ^ arabic !h4-number in
      let it-num = embed-string s-num in
      let ctx = ctx |> h4-heading in
      line-break true false ctx
        (read-inline ctx {#it-num;. #it;} ++ inline-fil)
    in
    heading-scheme ctx bb-title bt


  val get-quad-size ctx =
    get-font-size ctx *' font-ratio-cjk


  val block ctx +p it =
    let indent-size = 0pt in % get-quad-size ctx in
    line-break true true ctx
      (inline-skip indent-size ++ read-inline ctx it ++ inline-fil)


  val inline ctx \embed-list-block bt =
    embed-block-breakable ctx (read-block ctx bt) ++ inline-fil


  val block ctx +ul-block bts =
    let items =
      bts |> List.map (fun bt -> (
        Item({\embed-list-block(bt);}, [])
      ))
    in
    read-block ctx '<+Itemize.listing?(break = true)(Item({}, items));>


  val block ctx +ol-block bts =
    let items =
      bts |> List.map (fun bt -> (
        Item({\embed-list-block(bt);}, [])
      ))
    in
    read-block ctx '<+Itemize.listing?(break = true)(Item({}, items));>


  val fix-block-code s =
    string-unexplode [0x0A] ^ s
      % dirty trick; TODO: fix '+Code.code' and the parser of SATySFi


  val block ctx +code name s =
    let ctx = set-font-size (get-font-size ctx *' 0.875) ctx in
    let bt =
      if string-same name `console` then
        '<+Code.console(fix-block-code s);>
      else
        '<+Code.code(fix-block-code s);>
    in
    read-block ctx bt


  val block ctx +quote it =
    let qsize = get-quad-size ctx in
    let pads = (qsize, 0pt, 0pt, 0pt) in
    let decoset = VDecoSet.quote-round 6pt 4pt (Gray(0.75)) in
    block-frame-breakable ctx pads decoset
      (fun ctx -> read-block ctx it)


  val block ctx +hr =
    let w = get-text-width ctx in
    let h = hr-margin +' hr-thickness *' 0.5 in
    let color = (Gray(0.75)) in
    line-break true true ctx
      (inline-graphics w h h (fun (x, y) ->
        stroke hr-thickness color (Gr.line (x, y) (x +' w, y))
      ))


  val inline ctx \emph it =
    let ctx =
      ctx |> set-cjk-font font-cjk-gothic
          |> set-latin-font font-latin-sans
    in
    read-inline ctx it


  val inline \strong it =
    {\emph(it);}


  val strut h d =
    inline-graphics 0pt h d (fun _ -> unite-graphics [])


  val inline ctx \code s =
    let ib-strut = strut 8pt 3pt in
    let ib =
      let ctx =
        ctx
          |> set-latin-font font-latin-mono
          |> set-cjk-font font-cjk-gothic
          |> set-every-word-break inline-nil ib-strut
      in
        ib-strut ++ read-inline ctx (embed-string s)
    in
    let pads = (2pt, 2pt, 2pt, 2pt) in
    let decoset = HDecoSet.rectangle-round-fill 4pt 2pt code-background in
    script-guard Latin (inline-frame-breakable pads decoset ib)


  val inline ctx \reference tag display opt =
    let it = embed-string display in
    match opt with
    | None ->
        let () = display-message (`no reference for tag '` ^ tag ^ `'.`) in
        read-inline ctx it

    | Some((title, url)) ->
        let () = display-message (`tag = '` ^ tag ^ `'`) in
        let () = display-message (`display = '` ^ display ^ `'`) in
        let () = display-message (`title = '` ^ title ^ `'`) in
        let () = display-message (`url = '` ^ url ^ `'`) in
        let () = reference-acc <- (tag, title, url) :: !reference-acc in
        let key-pdf-loc = `reference:` ^ tag in
        let it-tag = embed-string tag in
        read-inline ctx {\jump(key-pdf-loc){#it; [#it-tag;]}}
    end


  val inline ctx \img alt src title =
    use-image-by-width (load-image src) 5cm


  val inline ctx \hard-break =
    Pervasives.mandatory-break ctx

end
