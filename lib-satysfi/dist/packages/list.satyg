
module List
: sig
    val map : ('a -> 'b) -> 'a list -> 'b list
    val mapi : (int -> 'a -> 'b) -> 'a list -> 'b list
    val iter : ('a -> unit) -> 'a list -> unit
    val iteri : (int -> 'a -> unit) -> 'a list -> unit
    val fold-left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
    val fold-lefti : (int -> 'a -> 'b -> 'a) -> 'a -> 'b list -> 'a
    val fold-right : ('a -> 'b -> 'b) -> 'b -> 'a list -> 'b
    val filter : ('a -> bool) -> 'a list -> 'a list
    val assoc : ('a -> 'a -> bool) -> 'a -> ('a * 'b) list -> 'b option
    val reverse : 'a list -> 'a list
    val append : 'a list -> 'a list -> 'a list
    val concat : ('a list) list -> 'a list
    val fold-left-adjacent : ('a -> 'b -> 'b option -> 'b option -> 'a) -> 'a -> 'b list -> 'a
    val map-adjacent : ('a -> 'a option -> 'a option -> 'b) -> 'a list -> 'b list
    val mapi-adjacent : (int -> 'a -> 'a option -> 'a option -> 'b) -> 'a list -> 'b list
    val length : 'a list -> int
    val nth : int -> 'a list -> 'a option
    val head : 'a list -> 'a option
    val tail : 'a list -> ('a list) option
    val reverse-append : 'a list -> 'a list -> 'a list
    val reverse-map : ('a -> 'b) -> 'a list -> 'b list
    val for-all : ('a -> bool) -> 'a list -> bool
    val exists : ('a -> bool) -> 'a list -> bool
    val for-all2 : ('a -> 'b -> bool) -> 'a list -> 'b list -> bool option
    val exists2 : ('a -> 'b -> bool) -> 'a list -> 'b list -> bool option
    val find : ('a -> bool) -> 'a list -> 'a option
    val partition : ('a -> bool) -> 'a list -> 'a list * 'a list
    val split : ('a * 'b) list -> 'a list * 'b list
    val combine : 'a list -> 'b list -> (('a * 'b) list) option
    val bubblesort : ('a -> 'a -> int) -> 'a list -> 'a list
  end
= struct

    let-rec map
      | f []        = []
      | f (x :: xs) = (f x) :: map f xs


    let mapi f =
      let-rec aux
        | i f []        = []
        | i f (x :: xs) = (f i x) :: aux (i + 1) f xs
      in
      aux 0 f


    let-rec iter
      | f []        = ()
      | f (x :: xs) = f x before iter f xs


    let iteri f =
      let-rec aux
        | i f []        = ()
        | i f (x :: xs) = f i x before aux (i + 1) f xs
      in
      aux 0 f


    let-rec fold-left
      | f init []        = init
      | f init (x :: xs) = fold-left f (f init x) xs


    let fold-lefti f =
      let-rec aux
        | i f init []        = init
        | i f init (x :: xs) = aux (i + 1) f (f i init x) xs
      in
      aux 0 f


    let-rec fold-right
      | f init []        = init
      | f init (x :: xs) = f x (fold-right f init xs)


    let-rec filter
      | _ []        = []
      | p (x :: xs) = if p x then x :: filter p xs else filter p xs


    let-rec assoc
      | _ _ []              = None
      | eq a ((x, y) :: xs) = if eq a x then Some(y) else assoc eq a xs


    let reverse lst =
      fold-left (fun acc x -> x :: acc) [] lst


    let-rec append lst1 lst2 =
      match lst1 with
      | []      -> lst2
      | x :: xs -> x :: append xs lst2


    let concat lst = fold-right append [] lst


    let fold-left-adjacent f =
      let-rec aux leftopt init lst =
        match lst with
        | [] ->
            init

        | head :: [] ->
            let initnew = f init head leftopt None in
            initnew

        | head :: ((right :: _) as tail) ->
            let initnew = f init head leftopt (Some(right)) in
            aux (Some(head)) initnew tail
      in
      aux None


    let map-adjacent f lst =
        lst |> fold-left-adjacent (fun acc x leftopt rightopt -> (
          f x leftopt rightopt :: acc
        )) [] |> reverse


    let mapi-adjacent f lst =
      let (_, acc) =
        lst |> fold-left-adjacent (fun (i, acc) x leftopt rightopt -> (
          (i + 1, f i x leftopt rightopt :: acc)
        )) (0, [])
      in
        reverse acc


    let length lst =
      fold-right (fun _ i -> i + 1) 0 lst


    let nth lst =
      let-rec aux i n xs =
        match xs with
        | []           -> None
        | head :: tail -> if n == i then Some(head) else aux (i + 1) n tail
      in
        aux 0 lst


    let (^&&) b-opt1 b-opt2 =
      match (b-opt1, b-opt2) with
      | (Some(b1), Some(b2)) -> Some(b1 && b2)
      | (_, _)               -> None


    let (^||) b-opt1 b-opt2 =
      match (b-opt1, b-opt2) with
      | (Some(b1), Some(b2)) -> Some(b1 || b2)
      | (_, _)               -> None


    let (^::) a-opt1 lst-opt2 =
      match (a-opt1, lst-opt2) with
      | (Some(x), Some(xs)) -> Some(x :: xs)
      | (_, _)              -> None



    let head lst =
      match lst with
      | []        -> None
      | head :: _ -> Some(head)


    let tail lst =
      match lst with
      | []        -> None
      | _ :: tail -> Some(tail)


    let-rec reverse-append lst1 lst2 =
      match lst1 with
      | []      -> lst2
      | x :: xs -> reverse-append xs (x :: lst2)


    let reverse-map f lst =
      let-rec rmap-f accu lst =
        match lst with
        | []        -> accu
        | (x :: xs) -> rmap-f (f x :: accu) xs
      in
        rmap-f [] lst


    let-rec for-all f lst =
      match lst with
      | []      -> true
      | x :: xs -> f x && for-all f xs


    let-rec exists f lst =
      match lst with
      | []      -> false
      | x :: xs -> f x || exists f xs


    let-rec for-all2 f lst1 lst2 =
      match (lst1, lst2) with
      |  ([], [])              -> Some(true)
      | (x1 :: xs1, x2 :: xs2) -> Some(f x1 x2) ^&& for-all2 f xs1 xs2
      | (_, _)                 -> None


    let-rec exists2 f lst1 lst2 =
      match (lst1, lst2) with
      | ([], [])               -> Some(false)
      | (x1 :: xs1, x2 :: xs2) -> Some(f x1 x2) ^|| (exists2 f xs1 xs2)
      | (_, _)                 -> None


    let-rec find f lst =
      match lst with
      | []      -> None
      | x :: xs -> if f x then Some(x) else find f xs


    let partition f lst =
      let-rec part yes no lst =
      match lst with
        | []      -> (reverse yes, reverse no)
        | x :: xs -> if f x then part (x :: yes) no xs else part yes (x :: no) xs
      in
        part [] [] lst


    let-rec split lst =
      match lst with
      | []       -> ([], [])
      | (x, y) :: xs -> let (rx, ry) = split xs in (x :: rx, y :: ry)


    let-rec combine lst1 lst2 =
      match (lst1, lst2) with
      | ([], [])               -> Some([])
      | (x1 :: xs1, x2 :: xs2) -> Some((x1, x2)) ^:: (combine xs1 xs2)
      | (_, _)                 -> None


    let-rec bubblesort f lst =
      let-rec last lst =
        match lst with
          | x :: [] -> x
          | _ :: xs -> last xs
      in
      let-rec init lst =
        match lst with
          | _ :: [] -> []
          | x :: xs -> x :: (init xs)
      in
      let-rec bs-sub lst =
        match lst with
          | (x :: y :: zs) -> (
              if (f x y) < 0 then
                y :: bs-sub (x :: zs)
              else
                x :: bs-sub (y :: zs)
            )
          | _ -> lst
      in
      let a = bs-sub lst in
      let x = last a in
      let xs = init a in
        match xs with
          | [] -> x :: []
          | _  -> x :: (bubblesort f xs)

  end
