# ---------------------------------------------------
#   SATySFi virtual machine instruction definitions
# ---------------------------------------------------
#
# This is formatted according to the YAML.
#
# This file is read by `gen_code.rb`.
# `gen_code.rb` generates OCaml source code and
# type declarations for
#
# * `types_template.ml`,
# * `ir_template.ml`,
# * `evaluator_template.ml`, and
# * `vm_template.ml`.
#
# Final source files that `gen_code.rb` generates are
#
# * `types_.ml`,
# * `ir_.ml`,
# * `evaluator_.ml`, and
# * `vm_.ml`.
#
# To add a new primitive,
#   1. Add a new instruction definition to this file.
#      (`is-primitive` should be yes.)
#   2. Add a new entry to primitives.ml.
#
#
# inst:          Instruction name (essential)
# is-primitive:  Primitive or pure vm instruction (default: no)
# needs-reducef: Use `reducef` for evaluating applications (default: no)
# suppress-pp:   Use a simple pritty printer (default: no)
# custom-pp:     Specify custom pritty printer
# no-ircode:     Suppress code generation for `ir_.ml` (default: no)
# no-interp:     Suppress code generation for `evaluator_.ml` (default: !`is-primitive`)
# name:          Identifier for the primitive
# type:          Type expression for the primitive
# fields:        Field list (for `abstract_tree` type)
# params:        Paramater list
# code:          Instruction code
#   (note: If `is-primitive` is yes, code that pushes to stack and
#          go to next instruction will be automatically inserted.
#          (see `gen_code.rb`))
#
---
inst: AccessField
fields:
- field_nm : field_name
params:
- value1
code: |
  match value1 with
  | RecordValue(asc1) ->
      begin
        match Assoc.find_opt asc1 field_nm with
        | Some(v) -> exec (v :: stack) env code dump
        | None    -> report_bug_vm ("AccessField field " ^ field_nm ^ " not found")
      end

  | _ -> report_bug_vm "not a Record"

---
inst: Apply
fields:
- n : int
params:
- f
code: |
  match f with
  | CompiledFuncWithEnvironment(arity, pargs, framesize, body, env1) ->
      if arity = n then
        begin
         if pargs = [] then
            exec stack (newframe env1 framesize) body ((env, code) :: dump)
          else
            let (args, stack) = popn stack n in
            let allargs = List.rev (pargs @ args) in
              exec (allargs @ stack) (newframe env1 framesize) body ((env, code) :: dump)
        end

      else if arity > n then
        let (args, stack) = popn stack n in
        let applied = CompiledFuncWithEnvironment(arity - n, pargs @ args, framesize, body, env1) in
          exec (applied :: stack) env code dump

      else
        let (surplus, stack) = popn stack (n - arity) in
        let (args, stack) = popn stack arity in
        let allargs = List.rev (pargs @ args) in
          exec (allargs @ stack) (newframe env1 framesize) body ((env, OpInsertArgs(surplus) :: OpApply(n - arity) :: code) :: dump)

   | CompiledPrimitiveWithEnvironment(arity, [], framesize, body, env1, astf) ->
     if arity = n then
       exec stack (newframe env1 framesize) body ((env, code) :: dump)

     else if arity > n then
       let (args, stack) = popn stack n in
        let applied = CompiledFuncWithEnvironment(arity - n, args, framesize, body, env1) in
          exec (applied :: stack) env code dump

     else
       let (surplus, stack) = popn stack (n - arity) in
         exec stack (newframe env1 framesize) body ((env, OpInsertArgs(surplus) :: OpApply(n - arity) :: code) :: dump)

   | _ -> report_bug_vm "Apply: not a function"

---
inst: ApplyT
fields:
- n : int
params:
- f
code: |
  match f with
  | CompiledFuncWithEnvironment(arity, pargs, framesize, body, env1) ->
    if arity = n then
      begin
       if pargs = [] then
          exec stack (newframe env1 framesize) body dump
        else
          let (args, stack) = popn stack n in
          let allargs = List.rev (pargs @ args) in
            exec (allargs @ stack) (newframe env1 framesize) body dump
      end

    else if arity > n then
      let (args, stack) = popn stack n in
      let applied = CompiledFuncWithEnvironment(arity - n, pargs @ args, framesize, body, env1) in
        exec (applied :: stack) env code dump

    else
      let (surplus, stack) = popn stack (n-arity) in
      let (args, stack) = popn stack arity in
      let allargs = List.rev (pargs @ args) in
        exec (allargs @ stack) (newframe env1 framesize) body ((env, OpInsertArgs(surplus) :: OpApplyT(n - arity) :: code) :: dump)

   | CompiledPrimitiveWithEnvironment(arity, [], framesize, body, env1, astf) ->
     if arity = n then
       exec stack (newframe env1 framesize) body dump

     else if arity > n then
       let (args, stack) = popn stack n in
        let applied = CompiledFuncWithEnvironment(arity - n, args, framesize, body, env1) in
          exec (applied :: stack) env code dump

     else
       let (surplus, stack) = popn stack (n-arity) in
         exec stack (newframe env1 framesize) body ((env, OpInsertArgs(surplus) :: OpApplyT(n - arity) :: code) :: dump)

   | _ -> report_bug_vm "ApplyT: not a function"

---
inst: BindGlobal
fields:
- loc : syntactic_value ref
- evid : EvalVarID.t
- refs : int
params:
- v
code: |
  loc := v;
  exec stack env code dump

---
inst: BindLocal
fields:
- lv : int
- offset : int
- evid : EvalVarID.t
- refs : int
params:
- v
code: |
  local_set_value env lv offset v;
  exec stack env code dump

---
inst: BindClosuresRec
fields:
- binds : (varloc * instruction list) list
code: |
  binds |> List.iter (fun (var, code) ->
    let recfunc = exec [] env code [] in
      match var with
      | GlobalVar(loc, evid, refs) -> loc := recfunc
      | LocalVar(lv, offset, evid, refs) -> local_set_value env lv offset recfunc
  );
  exec stack env code dump

---
inst: Branch
suppress-pp : yes
fields:
- body : instruction list
code: |
  exec stack env body dump

---
inst: BranchIf
suppress-pp : yes
fields:
- body : instruction list
params:
- b : bool
code: |
  if b then
    exec stack env body dump
  else
    exec stack env code dump

---
inst: BranchIfNot
suppress-pp : yes
fields:
- body : instruction list
params:
- b : bool
code: |
  if b then
    exec stack env code dump
  else
    exec stack env body dump

---
inst: LoadGlobal
custom-pp:
  (fun fmt (r, evid, refs) -> Format.fprintf fmt "OpLoadGlobal(%s)" (EvalVarID.show_direct evid))
fields:
- loc : syntactic_value ref
- evid : EvalVarID.t
- refs : int
code: |
  let v = !loc in
    exec (v :: stack) env code dump

---
inst: LoadLocal
fields:
- lv : int
- offset : int
- evid : EvalVarID.t
- refs : int
code: |
  let v = local_get_value env lv offset in
    exec (v :: stack) env code dump

---
inst: Dereference
is-primitive: yes
no-interp: yes
params:
- valuecont
code: |
  match valuecont with
  | Location(stid) ->
      begin
        match find_location_value (vmenv_global env) stid with
        | Some(value) -> value
        | None        -> report_bug_vm "Dereference"
      end

  | _ ->
      report_bug_vm "Dereference"

---
inst: Dup
code: |
  let v =
    try List.hd stack with
    | Invalid_argument(_) -> report_bug_vm "Dup: stack underflow"
  in
    exec (v :: stack) env code dump

---
inst: Error
fields:
- msg : string
code: |
  raise (ExecError(msg))

---
inst: MakeConstructor
fields:
- ctor_nm : constructor_name
params:
- valuecont
code: |
  exec (Constructor(ctor_nm, valuecont) :: stack) env code dump

---
inst: MakeRecord
suppress-pp : yes
fields:
- keylst : Assoc.key list
code: |
  let rec collect keys asc st =
    match keys with
    | [] ->
        (asc, st)

    | k :: rest ->
        begin
          match st with
          | v :: stnew -> collect rest (Assoc.add asc k v) stnew
          | _          -> report_bug_vm "MakeRecord: stack underflow"
        end
    in
    let (asc, stack) = collect (List.rev keylst) Assoc.empty stack in
      exec (RecordValue(asc) :: stack) env code dump

---
inst: MakeTuple
fields:
- len : int
code: |
  let rec iter n last st =
    if n <= 0 then
      (last, st)
    else
      match st with
      | value :: stnew -> iter (n - 1) (TupleCons(value, last)) stnew
      | []             -> report_bug_vm "MakeTuple: stack underflow"
  in
  let (tuple, stack) = iter len EndOfTuple stack in
    exec (tuple :: stack) env code dump

---
inst: Pop
code: |
  let stack =
    try List.tl stack with
    | Invalid_argument(_) -> report_bug_vm "Pop: stack underflow"
  in
    exec stack env code dump

---
inst: Push
fields:
- v : syntactic_value
code: |
  exec (v :: stack) env code dump

---
inst: PushEnv
code: |
  exec (EvaluatedEnvironment(vmenv_global env) :: stack) env code dump

---
inst: CheckStackTopBool
suppress-pp : yes
fields:
- b : bool
- next : instruction list
params:
- v
code: |
  match v with
  | BooleanConstant(b0) when b = b0 -> exec stack env code dump
  | _                               -> exec stack env next dump

---
inst: CheckStackTopCtor
suppress-pp : yes
fields:
- ctor_nm : constructor_name
- next : instruction list
params:
- v
code: |
  match v with
  | Constructor(nm, sub) when nm = ctor_nm -> exec (sub :: stack) env code dump
  | _                                      -> exec stack env next dump

---
inst: CheckStackTopEndOfList
suppress-pp : yes
fields:
- next : instruction list
params:
- v
code: |
  match v with
  | EndOfList -> exec stack env code dump
  | _         -> exec stack env next dump

---
inst: CheckStackTopInt
suppress-pp : yes
fields:
- i : int
- next : instruction list
params:
- v
code: |
  match v with
  | IntegerConstant(i0) when i=i0 -> exec stack env code dump
  | _                             -> exec stack env next dump

---
inst: CheckStackTopListCons
suppress-pp : yes
fields:
- next : instruction list
params:
- v
code: |
  match v with
  | ListCons(car, cdr) -> exec (car :: cdr :: stack) env code dump
  | _                  -> exec stack env next dump

---
inst: CheckStackTopStr
suppress-pp : yes
fields:
- str : string
- next : instruction list
params:
- v
code: |
  match v with
  | StringConstant(s0) when s0 = str -> exec stack env code dump
  | _                                -> exec stack env next dump

---
inst: CheckStackTopTupleCons
suppress-pp : yes
fields:
- next : instruction list
params:
- v
code: |
  match v with
  | TupleCons(car, cdr) -> exec (car :: cdr :: stack) env code dump
  | _                   -> exec stack env next dump

---
inst: Closure
fields:
- arity : int
- framesize : int
- body : instruction list
code: |
  exec (CompiledFuncWithEnvironment(arity, [], framesize, body, env) :: stack) env code dump

---
inst: ClosureInputHorz
fields:
- body : syntactic_value
code: |
  let imihclos = get_input_horz_content env body in
    exec (imihclos :: stack) env code dump

---
inst: ClosureInputVert
fields:
- body : syntactic_value
code: |
  let imivclos = get_input_vert_content env body in
    exec (imivclos :: stack) env code dump

---
inst: BindLocationGlobal
fields:
- loc : syntactic_value ref
- evid : EvalVarID.t
params:
- valueini
code: |
  let stid = register_location (vmenv_global env) valueini in
  loc := Location(stid);
    exec stack env code dump

---
inst: BindLocationLocal
fields:
- lv : int
- offset : int
- evid : EvalVarID.t
params:
- valueini
code: |
  let stid = register_location (vmenv_global env) valueini in
  local_set_value env lv offset (Location(stid));
    exec stack env code dump

---
inst: UpdateGlobal
suppress-pp : yes
fields:
- loc : syntactic_value ref
- evid : EvalVarID.t
params:
- valuenew
code: |
   match !loc with
   | Location(stid) ->
       begin
         update_location (vmenv_global env) stid valuenew;
         exec (UnitConstant :: stack) env code dump
       end

   | _ -> report_bug_vm "UpdateGlobal"

---
inst: UpdateLocal
suppress-pp : yes
fields:
- lv : int
- offset : int
- evid : EvalVarID.t
params:
- valuenew
code: |
  match local_get_value env lv offset with
  | Location(stid) ->
       begin
         update_location (vmenv_global env) stid valuenew;
         exec (UnitConstant :: stack) env code dump
       end

  | _ -> report_bug_vm "UpdateLocal"

---
inst: Sel
fields:
- tpart : instruction list
- fpart : instruction list
suppress-pp: yes
params:
- b : bool
code: |
  if b then
    exec stack env tpart dump
  else
    exec stack env fpart dump

---
inst: Concat
is-primitive: yes
name: "^"
type: |
  ~% (tS @-> tS @-> tS)

params:
- value1
- value2
code: |
  match (value1, value2) with
  | (StringEmpty, _)                         -> value2
  | (_, StringEmpty)                         -> value1
  | (StringConstant(s1), StringConstant(s2)) -> StringConstant(s1 ^ s2)
  | _                                        -> report_bug_vm "Concat"

---
inst: PrimitiveSetMathVariantToChar
is-primitive: yes
name: "set-math-variant-char"
type: |
  ~% (tS @-> tMCCLS @-> tMATHCLS @-> tI @-> tCTX @-> tCTX)

params:
- s : string
- mccls : math_char_class
- mathcls : math_class
- uchlst : uchar_list
- (ctx, v) : context
code: |
  let mvvalue = (mathcls, HorzBox.MathVariantToChar(false, uchlst)) in
  let mcclsmap = ctx.HorzBox.math_variant_char_map in
    Context(HorzBox.({ ctx with
      math_variant_char_map = mcclsmap |> MathVariantCharMap.add (s, mccls) mvvalue;
    }), v)

---
inst: PrimitiveSetMathCommand
is-primitive: yes
name: "set-math-command"
type: |
  ~% (tCMD @-> tCTX @-> tCTX)

params:
- valuecmd
- (ctx, _) : context
code: |
  Context(ctx, valuecmd)

---
inst: BackendMathVariantCharDirect
is-primitive: yes
name: "math-variant-char"
type: |
  ~% (tMATHCLS @-> tMCSTY @-> tMATH)

params:
- mathcls : math_class
- valuercd
code: |
  let is_big = false in  (* temporary *)
  let mvsty = get_math_variant_style valuercd in
    MathValue(HorzBox.([MathPure(MathVariantCharDirect(mathcls, is_big, mvsty))]))

---
inst: BackendMathConcat
is-primitive: yes
name: "math-concat"
type: |
  ~% (tMATH @-> tMATH @-> tMATH)

params:
- mlst1 : math
- mlst2 : math
code: |
  MathValue(List.append mlst1 mlst2)

---
inst: BackendMathGroup
is-primitive: yes
name: "math-group"
type: |
  ~% (tMATHCLS @-> tMATHCLS @-> tMATH @-> tMATH)

params:
- mathcls1 : math_class
- mathcls2 : math_class
- mlst : math
code: |
  MathValue([MathGroup(mathcls1, mathcls2, mlst)])

---
inst: BackendMathSuperscript
is-primitive: yes
name: "math-sup"
type: |
  ~% (tMATH @-> tMATH @-> tMATH)

params:
- mlst1 : math
- mlst2 : math
code: |
  MathValue([MathSuperscript(mlst1, mlst2)])

---
inst: BackendMathSubscript
is-primitive: yes
name: "math-sub"
type: |
  ~% (tMATH @-> tMATH @-> tMATH)

params:
- mlst1 : math
- mlst2 : math
code: |
  MathValue([MathSubscript(mlst1, mlst2)])

---
inst: BackendMathFraction
is-primitive: yes
name: "math-frac"
type: |
  ~% (tMATH @-> tMATH @-> tMATH)

params:
- mlst1 : math
- mlst2 : math
code: |
  MathValue([MathFraction(mlst1, mlst2)])

---
inst: BackendMathRadical
is-primitive: yes
name: "math-radical"
type: |
  ~% (tOPT tMATH @-> tMATH @-> tMATH)

params:
- value1mopt
- mlst2 : math
code: |
  let mlst1opt = get_option get_math value1mopt in
  let radical = Primitives.default_radical in  (* temporary; should be variable *)
    match mlst1opt with
    | None        -> MathValue([MathRadical(radical, mlst2)])
    | Some(mlst1) -> MathValue([MathRadicalWithDegree(mlst1, mlst2)])

---
inst: BackendMathParen
is-primitive: yes
name: "math-paren"
type: |
  ~% (tPAREN @-> tPAREN @-> tMATH @-> tMATH)

needs-reducef: yes
params:
- valueparenL
- valueparenR
- mlst1 : math
code: |
  let parenL = make_paren reducef valueparenL in
  let parenR = make_paren reducef valueparenR in
    MathValue([MathParen(parenL, parenR, mlst1)])

---
inst: BackendMathUpperLimit
is-primitive: yes
name: "math-upper"
type: |
  ~% (tMATH @-> tMATH @-> tMATH)

params:
- mlst1 : math
- mlst2 : math
code: |
  MathValue([MathUpperLimit(mlst1, mlst2)])

---
inst: BackendMathLowerLimit
is-primitive: yes
name: "math-lower"
type: |
  ~% (tMATH @-> tMATH @-> tMATH)

params:
- mlst1 : math
- mlst2 : math
code: |
  MathValue([MathLowerLimit(mlst1, mlst2)])

---
inst: BackendMathChar
is-primitive: yes
name: "math-char"
type: |
  ~% (tMATHCLS @-> tS @-> tMATH)

params:
- mathcls : math_class
- uchlst : uchar_list
code: |
  let mlst = [HorzBox.(MathPure(MathElement(mathcls, MathChar(false, uchlst))))] in
    MathValue(mlst)

---
inst: BackendMathBigChar
is-primitive: yes
name: "math-big-char"
type: |
  ~% (tMATHCLS @-> tS @-> tMATH)

params:
- mathcls : math_class
- uchlst : uchar_list
code: |
  let mlst = [HorzBox.(MathPure(MathElement(mathcls, MathChar(true, uchlst))))] in
    MathValue(mlst)

---
inst: BackendMathCharWithKern
is-primitive: yes
name: "math-char-with-kern"
type: |
  let mckf = tLN @-> tLN @-> tLN in
    ~% (tMATHCLS @-> tS @-> mckf @-> mckf @-> tMATH)

needs-reducef: yes
params:
- mathcls : math_class
- uchlst : uchar_list
- valuekernfL
- valuekernfR
code: |
  let kernfL = make_math_char_kern_func reducef valuekernfL in
  let kernfR = make_math_char_kern_func reducef valuekernfR in
  let mlst = [HorzBox.(MathPure(MathElement(mathcls, MathCharWithKern(false, uchlst, kernfL, kernfR))))] in
    MathValue(mlst)

---
inst: BackendMathBigCharWithKern
is-primitive: yes
name: "math-big-char-with-kern"
type: |
  let mckf = tLN @-> tLN @-> tLN in
    ~% (tMATHCLS @-> tS @-> mckf @-> mckf @-> tMATH)

needs-reducef: yes
params:
- mathcls : math_class
- uchlst : uchar_list
- valuekernfL
- valuekernfR
code: |
  let kernfL = make_math_char_kern_func reducef valuekernfL in
  let kernfR = make_math_char_kern_func reducef valuekernfR in
  let mlst = [HorzBox.(MathPure(MathElement(mathcls, MathCharWithKern(true, uchlst, kernfL, kernfR))))] in
    MathValue(mlst)

---
inst: BackendMathText
is-primitive: yes
name: "text-in-math"
type: |
  ~% (tMATHCLS @-> (tCTX @-> tIB) @-> tMATH)

needs-reducef: yes
params:
- mathcls : math_class
- valuef
code: |
  let hblstf ictx =
    let valueh = reducef valuef [Context(ictx)] in
      get_horz valueh
  in
    MathValue(HorzBox.([MathPure(MathElement(mathcls, MathEmbeddedText(hblstf)))]))

---
inst: BackendMathColor
is-primitive: yes
name: "math-color"
type: |
  ~% (tCLR @-> tMATH @-> tMATH)

params:
- color : color
- mlst : math
code: |
  MathValue(HorzBox.([MathChangeContext(MathChangeColor(color), mlst)]))

---
inst: BackendMathCharClass
is-primitive: yes
name: "math-char-class"
type: |
  ~% (tMCCLS @-> tMATH @-> tMATH)

params:
- mccls : math_char_class
- mlst : math
code: |
  MathValue(HorzBox.([MathChangeContext(MathChangeMathCharClass(mccls), mlst)]))

---
inst: BackendMathList
no-ircode: yes
fields:
- n : int
code: |
  let rec iter n st acc =
    if n <= 0 then
      (acc, st)
    else
      match st with
      | MathValue(m) :: stnew -> iter (n - 1) stnew (m :: acc)
      | _                     -> report_bug_vm "BackendMathList"
  in
  let (mlst, stack) = iter n stack [] in
    exec (MathValue(List.concat mlst) :: stack) env code dump

---
inst: BackendEmbeddedMath
is-primitive: yes
name: "embed-math"
type: |
  ~% (tCTX @-> tMATH @-> tIB)

params:
- ictx : context
- mlst : math
code: |
  let mathctx = MathContext.make ictx in
  let hblst = Math.main mathctx mlst in
    Horz(hblst)

---
inst: BackendTabular
is-primitive: yes
name: "tabular"
type: |
  ~% ((tL (tL tCELL)) @-> tRULESF @-> tIB)

needs-reducef : yes
params:
- valuetabular
- valuerulesf
code: |
  let tabular = get_list (get_list get_cell) valuetabular in
  let (imtabular, widlst, lenlst, wid, hgt, dpt) = Tabular.main tabular in
  let rulesf xs ys =
    let valuexs = make_length_list xs in
    let valueys = make_length_list ys in
    let valueret = reducef valuerulesf [valuexs; valueys] in
      graphics_of_list valueret
  in
    Horz(HorzBox.([HorzPure(PHGFixedTabular(wid, hgt, dpt, imtabular, widlst, lenlst, rulesf))]))

---
inst: BackendRegisterPdfImage
is-primitive: yes
name: "load-pdf-image"
type: |
  ~% (tS @-> tI @-> tIMG)

params:
- srcpath : string
- pageno : int
code: |
  let imgkey = ImageInfo.add_pdf srcpath pageno in
    ImageKey(imgkey)

---
inst: BackendRegisterOtherImage
is-primitive: yes
name: "load-image"
type: |
  ~% (tS @-> tIMG)

params:
- srcpath : string
code: |
  let imgkey = ImageInfo.add_image srcpath in
    ImageKey(imgkey)

---
inst: BackendUseImageByWidth
is-primitive: yes
name: "use-image-by-width"
type: |
  ~% (tIMG @-> tLN @-> tIB)

params:
- valueimg
- wid : length
code: |
  match valueimg with
  | ImageKey(imgkey) ->
      let hgt = ImageInfo.get_height_from_width imgkey wid in
        Horz(HorzBox.([HorzPure(PHGFixedImage(wid, hgt, imgkey))]))

  | _ -> report_bug_vm "BackendUseImage"

---
inst: BackendHookPageBreak
is-primitive: yes
name: "hook-page-break"
type: |
  ~% ((tPBINFO @-> tPT @-> tU) @-> tIB)

needs-reducef: yes
params:
- hookf
code: |
  let hookf = make_hook reducef hookf in
    Horz(HorzBox.([HorzPure(PHGHookPageBreak(hookf))]))

---
inst: Path
suppress-pp : yes
is-primitive : yes
separated: yes
no-ircode: yes
no-interp: yes
fields:
- c_pathcomplst : ((instruction list) compiled_path_component) list
- c_cycleopt : (unit compiled_path_component) option
params:
- pt0 : point
code: |
  let (pathelemlst, closingopt) = get_path env c_pathcomplst c_cycleopt in
    PathValue([GraphicData.GeneralPath(pt0, pathelemlst, closingopt)])

---
inst: PathUnite
is-primitive: yes
name: "unite-path"
type: |
  ~% (tPATH @-> tPATH @-> tPATH)

params:
- pathlst1 : path_value
- pathlst2 : path_value
code: |
  PathValue(List.append pathlst1 pathlst2)

---
inst: PrePathBeginning
is-primitive: yes
name: "start-path"
type: |
  ~% (tPT @-> tPRP)

params:
- pt0 : point
code: |
  PrePathValue(PrePath.start pt0)

---
inst: PrePathLineTo
is-primitive: yes
name: "line-to"
type: |
  ~% (tPT @-> tPRP @-> tPRP)

params:
- pt1 : point
- prepath : prepath
code: |
  PrePathValue(prepath |> PrePath.line_to pt1)

---
inst: PrePathCubicBezierTo
is-primitive: yes
name: "bezier-to"
type: |
  ~% (tPT @-> tPT @-> tPT @-> tPRP @-> tPRP)

params:
- ptS : point
- ptT : point
- pt1 : point
- prepath: prepath
code: |
  PrePathValue(prepath |> PrePath.bezier_to ptS ptT pt1)

---
inst: PrePathTerminate
is-primitive: yes
name: "terminate-path"
type: |
  ~% (tPRP @-> tPATH)

params:
- prepath : prepath
code: |
  PathValue([prepath |> PrePath.terminate])

---
inst: PrePathCloseWithLine
is-primitive: yes
name: "close-with-line"
type: |
  ~% (tPRP @-> tPATH)

params:
- prepath : prepath
code: |
  PathValue([prepath |> PrePath.close_with_line])

---
inst: PrePathCloseWithCubicBezier
is-primitive: yes
name: "close-with-bezier"
type: |
  ~% (tPT @-> tPT @-> tPRP @-> tPATH)

params:
- ptS : point
- ptT : point
- prepath : prepath
code: |
  PathValue([prepath |> PrePath.close_with_bezier ptS ptT])

---
inst: HorzConcat
is-primitive: yes
name: "++"
type: |
  ~% (tIB @-> tIB @-> tIB)

params:
- hblst1 : horz
- hblst2 : horz
code: |
  Horz(List.append hblst1 hblst2)

---
inst: VertConcat
is-primitive: yes
name: "+++"
type: |
  ~% (tBB @-> tBB @-> tBB)

params:
- vblst1 : vert
- vblst2 : vert
code: |
  Vert(List.append vblst1 vblst2)

---
inst: HorzLex
is-primitive: yes
name: "read-inline"
type: |
  ~% (tCTX @-> tIT @-> tIB)

separated: yes
params:
- valuectx
- value1
code: |
  match value1 with
  | CompiledInputHorzWithEnvironment(imihlst, envi) -> exec_intermediate_input_horz envi valuectx imihlst
  | _                                               -> report_bug_vm "HorzLex"

code-interp: |
  match value1 with
  | InputHorzWithEnvironment(imihlst, envi) -> interpret_intermediate_input_horz envi valuectx imihlst
  | _                                       -> report_bug_value "HorzLex" value1

---
inst: VertLex
is-primitive: yes
name: "read-block"
type: |
  ~% (tCTX @-> tBT @-> tBB)

separated: yes
params:
- valuectx
- value1
code: |
  match value1 with
  | CompiledInputVertWithEnvironment(imivlst, envi) -> exec_intermediate_input_vert envi valuectx imivlst
  | _                                               -> report_bug_vm "VertLex"

code-interp: |
  match value1 with
  | InputVertWithEnvironment(imivlst, envi) -> interpret_intermediate_input_vert envi valuectx imivlst
  | _                                       -> report_bug_value "VertLex" value1

---
inst: BackendFont
is-primitive: yes
params:
- abbrev : string
- size_ratio : float
- rising_ratio : float
code: |
  make_font_value (abbrev, size_ratio, rising_ratio)

---
inst: BackendLineBreaking
is-primitive: yes
name: "line-break"
type: |
  ~% (tB @-> tB @-> tCTX @-> tIB @-> tBB)

params:
- is_breakable_top : bool
- is_breakable_bottom : bool
- (ctx,  _) : context
- hblst : horz
code: |
  let imvblst = HorzBox.(LineBreak.main is_breakable_top is_breakable_bottom ctx.paragraph_top ctx.paragraph_bottom ctx hblst) in
    Vert(imvblst)

---
inst: BackendPageBreaking
is-primitive: yes
name: "page-break"
type: |
  ~% (tPG @-> tPAGECONTF @-> tPAGEPARTSF @-> tBB @-> tDOC)

needs-reducef: yes
params:
- pagesize : page_size
- valuepagecontf
- valuepagepartsf
- vblst : vert
code: |
  let pagecontf = make_page_content_scheme_func reducef valuepagecontf in
  let pagepartsf = make_page_parts_scheme_func reducef valuepagepartsf in
    DocumentValue(pagesize, pagecontf, pagepartsf, vblst)

---
inst: BackendVertFrame
is-primitive: yes
name: "block-frame-breakable"
type: |
  ~% (tCTX @-> tPADS @-> tDECOSET @-> (tCTX @-> tBB) @-> tBB)

needs-reducef : yes
params:
- (ctx, valuecmd) : context
- pads : paddings
- (valuedecoS, valuedecoH, valuedecoM, valuedecoT) : decoset
- valuek
code: |
  let valuectxsub =
    Context(HorzBox.({ ctx with
      paragraph_width = HorzBox.(ctx.paragraph_width -% pads.paddingL -% pads.paddingR);
    }), valuecmd)
  in
  let vblst =
    let valuev = reducef valuek [valuectxsub] in
      get_vert valuev
  in
    Vert(HorzBox.([
      VertTopMargin(true, ctx.paragraph_top);
      VertFrame(pads,
                  make_frame_deco reducef valuedecoS,
                  make_frame_deco reducef valuedecoH,
                  make_frame_deco reducef valuedecoM,
                  make_frame_deco reducef valuedecoT,
                  ctx.paragraph_width, vblst);
      VertBottomMargin(true, ctx.paragraph_bottom);
  ]))

---
inst: BackendEmbeddedVertTop
is-primitive: yes
name: "embed-block-top"
type: |
  ~% (tCTX @-> tLN @-> (tCTX @-> tBB) @-> tIB)

needs-reducef : yes
params:
- (ctx, valuecmd) : context
- wid : length
- valuek
code: |
  let valuectxsub =
    Context(HorzBox.({ ctx with paragraph_width = wid; }), valuecmd)
  in
  let vblst =
    let valuev = reducef valuek [valuectxsub] in
      get_vert valuev
  in
  let imvblst = PageBreak.solidify vblst in
  let (hgt, dpt) = adjust_to_first_line imvblst in
    Horz(HorzBox.([HorzPure(PHGEmbeddedVert(wid, hgt, dpt, imvblst))]))

---
inst: BackendVertSkip
is-primitive: yes
name: "block-skip"
type: |
  ~% (tLN @-> tBB)

params:
- len : length
code: |
  Vert(HorzBox.([VertFixedBreakable(len)]))

---
inst: BackendEmbeddedVertBottom
is-primitive: yes
name: "embed-block-bottom"
type: |
  ~% (tCTX @-> tLN @-> (tCTX @-> tBB) @-> tIB)

needs-reducef : yes
params:
- (ctx, valuecmd) : context
- wid : length
- valuek
code: |
  let valuectxsub =
    Context(HorzBox.({ ctx with paragraph_width = wid; }), valuecmd)
  in
  let vblst =
    let valuev = reducef valuek [valuectxsub] in
      get_vert valuev
  in
  let imvblst = PageBreak.solidify vblst in
  let (hgt, dpt) = adjust_to_last_line imvblst in
    Horz(HorzBox.([HorzPure(PHGEmbeddedVert(wid, hgt, dpt, imvblst))]))

---
inst: BackendLineStackTop
is-primitive: yes
name: "line-stack-top"
type: |
  ~% ((tL tIB) @-> tIB)

params:
- valuehblstlst
code: |
  let hblstlst = get_list get_horz valuehblstlst in
  let (wid, vblst) = make_line_stack hblstlst in
  let imvblst = PageBreak.solidify vblst in
  let (hgt, dpt) = adjust_to_first_line imvblst in
    Horz(HorzBox.([HorzPure(PHGEmbeddedVert(wid, hgt, dpt, imvblst))]))

---
inst: BackendLineStackBottom
is-primitive: yes
name: "line-stack-bottom"
type: |
  ~% ((tL tIB) @-> tIB)

params:
- valuehblstlst
code: |
  let hblstlst = get_list get_horz valuehblstlst in
  let (wid, vblst) = make_line_stack hblstlst in
  let imvblst = PageBreak.solidify vblst in
  let (hgt, dpt) = adjust_to_last_line imvblst in
    Horz(HorzBox.([HorzPure(PHGEmbeddedVert(wid, hgt, dpt, imvblst))]))

---
inst: PrimitiveGetInitialContext
is-primitive: yes
name: "get-initial-context"
type: |
  ~% (tLN @-> tCMD @-> tCTX)

params:
- txtwid : length
- valuecmd
code: |
  Context(Primitives.get_initial_context txtwid, valuecmd)

---
inst: PrimitiveSetSpaceRatio
is-primitive: yes
name: "set-space-ratio"
type: |
  ~% (tFL @-> tCTX @-> tCTX)

params:
- ratio : float
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with space_natural = ratio; }), valuecmd)

---
inst: PrimitiveSetParagraphMargin
is-primitive: yes
name: "set-paragraph-margin"
type: |
  ~% (tLN @-> tLN @-> tCTX @-> tCTX)

params:
- lentop : length
- lenbottom : length
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with
    paragraph_top    = lentop;
    paragraph_bottom = lenbottom;
  }), valuecmd)

---
inst: PrimitiveSetFontSize
is-primitive: yes
name: "set-font-size"
type: |
  ~% (tLN @-> tCTX @-> tCTX)

params:
- size : length
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with font_size = size; }), valuecmd)

---
inst: PrimitiveGetFontSize
is-primitive: yes
name: "get-font-size"
type: |
  ~% (tCTX @-> tLN)

params:
- (ctx, _) : context
code: |
  LengthConstant(ctx.HorzBox.font_size)

---
inst: PrimitiveSetFont
is-primitive: yes
name: "set-font"
type: |
  ~% (tSCR @-> tFONT @-> tCTX @-> tCTX)

params:
- script : script
- font_info : font
- (ctx, valuecmd) : context
code: |
  let font_scheme_new = HorzBox.(ctx.font_scheme |> CharBasis.ScriptSchemeMap.add script font_info) in
    Context(HorzBox.({ ctx with font_scheme = font_scheme_new; }), valuecmd)

---
inst: PrimitiveGetFont
is-primitive: yes
name: "get-font"
type: |
  ~% (tSCR @-> tCTX @-> tFONT)

params:
- script : script
- (ctx, _) : context
code: |
  let fontwr = HorzBox.get_font_with_ratio ctx script in
    make_font_value fontwr

---
inst: PrimitiveSetMathFont
is-primitive: yes
name: "set-math-font"
type: |
  ~% (tS @-> tCTX @-> tCTX)

params:
- mfabbrev : string
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with math_font = mfabbrev; }), valuecmd)

---
inst: PrimitiveSetDominantWideScript
is-primitive: yes
name: "set-dominant-wide-script"
type: |
  ~% (tSCR @-> tCTX @-> tCTX)

params:
- script: script
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with dominant_wide_script = script; }), valuecmd)

---
inst: PrimitiveGetDominantWideScript
is-primitive: yes
name: "get-dominant-wide-script"
type: |
  ~% (tCTX @-> tSCR)

params:
- (ctx, _) : context
code: |
  make_script_value ctx.HorzBox.dominant_wide_script

---
inst: PrimitiveSetDominantNarrowScript
is-primitive: yes
name: "set-dominant-narrow-script"
type: |
  ~% (tSCR @-> tCTX @-> tCTX)

params:
- script : script
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with dominant_narrow_script = script; }), valuecmd)

---
inst: PrimitiveGetDominantNarrowScript
is-primitive: yes
name: "get-dominant-narrow-script"
type: |
  ~% (tCTX @-> tSCR)

params:
- (ctx, _) : context
code: |
  make_script_value ctx.HorzBox.dominant_narrow_script

---
inst: PrimitiveSetLangSys
is-primitive: yes
name: "set-language"
type: |
  ~% (tSCR @-> tLANG @-> tCTX @-> tCTX)

params:
- script : script
- langsys : language_system
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with
    langsys_scheme = ctx.langsys_scheme |> CharBasis.ScriptSchemeMap.add script langsys;
  }), valuecmd)

---
inst: PrimitiveGetLangSys
is-primitive: yes
name: "get-language"
type: |
  ~% (tSCR @-> tCTX @-> tLANG)

params:
- script : script
- (ctx, _) : context
code: |
  let langsys = HorzBox.get_language_system ctx script in
    make_language_system_value langsys

---
inst: PrimitiveSetTextColor
is-primitive: yes
name: "set-text-color"
type: |
  ~% (tCLR @-> tCTX @-> tCTX)

params:
- color : color
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with text_color = color; }), valuecmd)

---
inst: PrimitiveGetTextColor
is-primitive: yes
name: "get-text-color"
type: |
  ~% (tCTX @-> tCLR)

params:
- (ctx, _) : context
code: |
  let color = ctx.HorzBox.text_color in
    make_color_value color

---
inst: PrimitiveSetLeading
is-primitive: yes
name: "set-leading"
type: |
  ~% (tLN @-> tCTX @-> tCTX)

params:
- len : length
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with leading = len; }), valuecmd)

---
inst: PrimitiveGetTextWidth
is-primitive: yes
name: "get-text-width"
type: |
  ~% (tCTX @-> tLN)

params:
- (ctx, _) : context
code: |
  LengthConstant(ctx.HorzBox.paragraph_width)

---
inst: PrimitiveSetManualRising
is-primitive: yes
name: "set-manual-rising"
type: |
  ~% (tLN @-> tCTX @-> tCTX)

params:
- rising : length
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with manual_rising = rising; }), valuecmd)

---
inst: PrimitiveSetHyphenPenalty
is-primitive: yes
name: "set-hyphen-penalty"
type: |
  ~% (tI @-> tCTX @-> tCTX)

params:
- pnlty : int
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with hyphen_badness = pnlty; }), valuecmd)

---
inst: PrimitiveEmbed
is-primitive: yes
name: "embed-string"
type: |
  ~% (tS @-> tIT)

separated: yes
params:
- str : string
code: |
  CompiledInputHorzWithEnvironment([CompiledImInputHorzText(str)], env)

code-interp: |
  InputHorzWithEnvironment([ImInputHorzText(str)], env)

---
inst: PrimitiveGetAxisHeight
is-primitive: yes
name: "get-axis-height"
type: |
  ~% (tCTX @-> tLN)

params:
- (ctx, _) : context
code: |
  let fontsize = ctx.HorzBox.font_size in
  let mfabbrev = ctx.HorzBox.math_font in
  let hgt = FontInfo.get_axis_height mfabbrev fontsize in
    LengthConstant(hgt)

---
inst: BackendFixedEmpty
is-primitive: yes
name: "inline-skip"
type: |
  ~% (tLN @-> tIB)

params:
- wid : length
code: |
  Horz([HorzBox.HorzPure(HorzBox.PHSFixedEmpty(wid))])

---
inst: BackendOuterEmpty
is-primitive: yes
name: "inline-glue"
type: |
  ~% (tLN @-> tLN @-> tLN @-> tIB)

params:
- widnat : length
- widshrink : length
- widstretch : length
code: |
  Horz([HorzBox.HorzPure(HorzBox.PHSOuterEmpty(widnat, widshrink, widstretch))])

---
inst: BackendOuterFrame
is-primitive: yes
name: "inline-frame-outer"
type: |
  ~% (tPADS @-> tDECO @-> tIB @-> tIB)

needs-reducef: yes
params:
- pads : paddings
- valuedeco
- hblst : horz
code: |
  Horz([HorzBox.HorzPure(HorzBox.PHGOuterFrame(
    pads,
    make_frame_deco reducef valuedeco,
    hblst))])

---
inst: BackendInnerFrame
is-primitive: yes
name: "inline-frame-inner"
type: |
  ~% (tPADS @-> tDECO @-> tIB @-> tIB)

needs-reducef: yes
params:
- pads : paddings
- valuedeco
- hblst : horz
code: |
  Horz([HorzBox.HorzPure(HorzBox.PHGInnerFrame(
    pads,
    make_frame_deco reducef valuedeco,
    hblst))])

---
inst: BackendFixedFrame
is-primitive: yes
name: "inline-frame-fixed"
type: |
  ~% (tLN @-> tPADS @-> tDECO @-> tIB @-> tIB)

needs-reducef: yes
params:
- wid : length
- pads : paddings
- hblst : horz
- valuedeco
code: |
  Horz([HorzBox.HorzPure(HorzBox.PHGFixedFrame(
    pads, wid,
    make_frame_deco reducef valuedeco,
    hblst))])

---
inst: BackendOuterFrameBreakable
is-primitive: yes
name: "inline-frame-breakable"
type: |
  ~% (tPADS @-> tDECOSET @-> tIB @-> tIB)

needs-reducef: yes
params:
- pads : paddings
- (valuedecoS, valuedecoH, valuedecoM, valuedecoT) : decoset
- hblst : horz
code: |
  Horz([HorzBox.HorzFrameBreakable(
    pads, Length.zero, Length.zero,
    make_frame_deco reducef valuedecoS,
    make_frame_deco reducef valuedecoH,
    make_frame_deco reducef valuedecoM,
    make_frame_deco reducef valuedecoT,
    hblst
  )])

---
inst: BackendInlineGraphics
is-primitive: yes
name: "inline-graphics"
type: |
  ~% (tLN @-> tLN @-> tLN @-> tIGR @-> tIB)

needs-reducef: yes
params:
- wid : length
- hgt : length
- dpt : length
- valueg
code: |
  let graphics = make_inline_graphics reducef valueg in
    Horz(HorzBox.([HorzPure(PHGFixedGraphics(wid, hgt, Length.negate dpt, graphics))]))

---
inst: BackendScriptGuard
is-primitive: yes
name: "script-guard"
type: |
  ~% (tSCR @-> tIB @-> tIB)

params:
- script : script
- hblst : horz
code: |
  Horz(HorzBox.([HorzScriptGuard(script, hblst)]))

---
inst: BackendDiscretionary
is-primitive: yes
name: "discretionary"
type: |
  ~% (tI @-> tIB @-> tIB @-> tIB @-> tIB)

params:
- pb : int
- hblst0 : horz
- hblst1 : horz
- hblst2 : horz
code: |
  Horz(HorzBox.([HorzDiscretionary(pb, hblst0, hblst1, hblst2)]))

---
inst: BackendRegisterCrossReference
is-primitive: yes
name: "register-cross-reference"
type: |
  ~% (tS @-> tS @-> tU)

params:
- k : string
- v : string
code: |
  CrossRef.register k v;
  UnitConstant

---
inst: BackendGetCrossReference
is-primitive: yes
name: "get-cross-reference"
type: |
  ~% (tS @-> (tOPT tS))

params:
- k : string
code: |
  match CrossRef.get k with
  | None    -> Constructor("None", UnitConstant)
  | Some(v) -> Constructor("Some", StringConstant(v))

---
inst: PrimitiveGetNaturalWidth
is-primitive: yes
name: "get-natural-width"
type: |
  ~% (tIB @-> tLN)

params:
- hblst : horz
code: |
  let (wid, _, _) = LineBreak.get_natural_metrics hblst in
    LengthConstant(wid)

---
inst: PrimitiveGetNaturalLength
is-primitive: yes
name: "get-natural-length"
type: |
  ~% (tBB @-> tLN)

params:
- vblst : vert
code: |
  let imvblst = PageBreak.solidify vblst in
  let (hgt, dpt) = adjust_to_first_line imvblst in
    LengthConstant(hgt +% (Length.negate dpt))

---
inst: PrimitiveDisplayMessage
is-primitive: yes
name: "display-message"
type: |
  ~% (tS @-> tU)

params:
- str : string
code: |
  print_endline str;
  UnitConstant

---
inst: PrimitiveListCons
is-primitive: yes
params:
- valuehd
- valuetl
code: |
  ListCons(valuehd, valuetl)

---
inst: PrimitiveSame
is-primitive: yes
name: "string-same"
type: |
  ~% (tS @-> tS @-> tB)

params:
- str1 : string
- str2 : string
code: |
  BooleanConstant(String.equal str1 str2)

---
inst: PrimitiveStringSub
is-primitive: yes
name: "string-sub"
type: |
  ~% (tS @-> tI @-> tI @-> tS)

params:
- str : string
- pos : int
- wid : int
code: |
  let resstr =
  try String.sub str pos wid with
  | Invalid_argument(s) -> report_dynamic_error "illegal index for string-sub"
  in
    StringConstant(resstr)

---
inst: PrimitiveStringLength
is-primitive: yes
name: "string-length"
type: |
  ~% (tS @-> tI)

params:
- str : string
code: |
  IntegerConstant(String.length str)

---
inst: PrimitiveStringUnexplode
is-primitive: yes
name: "string-unexplode"
type: |
  ~% ((tL tI) @-> tS)

params:
- valueilst
code: |
  let ilst = get_list get_int valueilst in
  let s = (List.map Uchar.of_int ilst) |> InternalText.of_uchar_list |> InternalText.to_utf8 in
    StringConstant(s)

---
inst: PrimitiveRegExpOfString
is-primitive: yes
name: "regexp-of-string"
type: |
  ~% (tS @-> tRE)

params:
- str : string
code: |
  let regexp =
    try Str.regexp str with
    | Failure(msg) -> report_dynamic_error ("regexp-of-string: " ^ msg)
  in
    RegExpConstant(regexp)

---
inst: PrimitiveStringMatch
is-primitive: yes
name: "string-match"
type: |
  ~% (tRE @-> tS @-> tB)

params:
- pat : regexp
- s : string
code: |
  BooleanConstant(Str.string_match pat s 0)

---
inst: PrimitiveSplitIntoLines
is-primitive: yes
name: "split-into-lines"
type: |
  ~% (tS @-> (tL (tPROD [tI; tS])))

params:
- s : string
code: |
  let slst = String.split_on_char '\n' s in
  let pairlst = slst |> List.map chop_space_indent in
    (pairlst |> make_list (fun (i, s) ->
      TupleCons(IntegerConstant(i), TupleCons(StringConstant(s), EndOfTuple))))

---
inst: PrimitiveSplitOnRegExp
is-primitive: yes
name: "split-on-regexp"
type: |
  ~% (tRE @-> tS @-> (tL (tPROD [tI; tS])))

params:
- sep : regexp
- str : string
code: |
  let slst = Str.split sep str in
  let pairlst = slst |> List.map chop_space_indent in
    (pairlst |> make_list (fun (i, s) ->
      TupleCons(IntegerConstant(i), TupleCons(StringConstant(s), EndOfTuple))))

---
inst: PrimitiveArabic
is-primitive: yes
name: "arabic"
type: |
  ~% (tI @-> tS)

params:
- num : int
code: |
  StringConstant(string_of_int num)

---
inst: PrimitiveFloat
is-primitive: yes
name: "float"
type: |
  ~% (tI @-> tFL)

params:
- ic1 : int
code: |
  FloatConstant(float_of_int ic1)

---
inst: PrimitiveRound
is-primitive: yes
name: "round"
type: |
  ~% (tFL @-> tI)

params:
- fc1 : float
code: |
  IntegerConstant(int_of_float fc1)

---
inst: PrimitiveDrawText
is-primitive: yes
name: "draw-text"
type: |
  ~% (tPT @-> tIB @-> tGR)

params:
- pt : point
- hblst : horz
code: |
  let (imhblst, _, _) = LineBreak.natural hblst in
  let grelem = Graphics.make_text pt imhblst in
    GraphicsValue(grelem)

---
inst: PrimitiveDrawStroke
is-primitive: yes
name: "stroke"
type: |
  ~% (tLN @-> tCLR @-> tPATH @-> tGR)

params:
- wid : length
- color : color
- pathlst : path_value
code: |
  let grelem = Graphics.make_stroke wid color pathlst in
    GraphicsValue(grelem)

---
inst: PrimitiveDrawFill
is-primitive: yes
name: "fill"
type: |
  ~% (tCLR @-> tPATH @-> tGR)

params:
- color : color
- pathlst : path_value
code: |
  let grelem = Graphics.make_fill color pathlst in
    GraphicsValue(grelem)

---
inst: PrimitiveDrawDashedStroke
is-primitive: yes
name: "dashed-stroke"
type: |
  ~% (tLN @-> tDASH @-> tCLR @-> tPATH @-> tGR)

params:
- wid : length
- valuetup3
- color : color
- pathlst : path_value
code: |
  let (len1, len2, len3) = get_tuple3 get_length valuetup3 in
  let grelem = Graphics.make_dashed_stroke wid (len1, len2, len3) color pathlst in
    GraphicsValue(grelem)

---
inst: Times
is-primitive: yes
name: "*"
type: |
  ~% (tI @-> tI @-> tI)

params:
- numl : int
- numr : int
code: |
  IntegerConstant(numl * numr)

---
inst: Divides
is-primitive: yes
name: "/"
type: |
  ~% (tI @-> tI @-> tI)

params:
- numl : int
- numr : int
code: |
  try IntegerConstant(numl / numr) with
  | Division_by_zero -> report_dynamic_error "division by zero"

---
inst: Mod
is-primitive: yes
name: "mod"
type: |
  ~% (tI @-> tI @-> tI)

params:
- numl : int
- numr : int
code: |
  try IntegerConstant(numl mod numr) with
  | Division_by_zero -> report_dynamic_error "division by zero"

---
inst: Plus
is-primitive: yes
name: "+"
type: |
  ~% (tI @-> tI @-> tI)

params:
- numl : int
- numr : int
code: |
  IntegerConstant(numl + numr)

---
inst: Minus
is-primitive: yes
name: "-"
type: |
  ~% (tI @-> tI @-> tI)

params:
- numl : int
- numr : int
code: |
  IntegerConstant(numl - numr)

---
inst: EqualTo
is-primitive: yes
name: "=="
type: |
  ~% (tI @-> tI @-> tB)

params:
- numl : int
- numr : int
code: |
  BooleanConstant(numl = numr)

---
inst: GreaterThan
is-primitive: yes
name: ">"
type: |
  ~% (tI @-> tI @-> tB)

params:
- numl : int
- numr : int
code: |
  BooleanConstant(numl > numr)

---
inst: LessThan
is-primitive: yes
name: "<"
type: |
  ~% (tI @-> tI @-> tB)

params:
- numl : int
- numr : int
code: |
  BooleanConstant(numl < numr)

---
inst: LogicalAnd
is-primitive: yes
name: "&&"
type: |
  ~% (tB @-> tB @-> tB)

params:
- binl : bool
- binr : bool
code: |
  BooleanConstant(binl && binr)

---
inst: LogicalOr
is-primitive: yes
name: "||"
type: |
  ~% (tB @-> tB @-> tB)

params:
- binl : bool
- binr : bool
code: |
  BooleanConstant(binl || binr)

---
inst: LogicalNot
is-primitive: yes
name: "not"
type: |
  ~% (tB @-> tB)

params:
- binl : bool
code: |
  BooleanConstant(not binl)

---
inst: BitShiftRight
is-primitive: yes
name: ">>"
type: |
  ~% (tI @-> tI @-> tI)

params:
- numl : int
- numr : int
code: |
  let bits =
    try numl lsr numr with
      | Invalid_argument(s) -> report_dynamic_error "Bit offset out of bounds for '>>'" in
  IntegerConstant(bits)

---
inst: BitShiftLeft
is-primitive: yes
name: "<<"
type: |
  ~% (tI @-> tI @-> tI)

params:
- numl : int
- numr : int
code: |
  let bits =
    try numl lsl numr with
      | Invalid_argument(s) -> report_dynamic_error "Bit offset out of bounds for '<<'" in
  IntegerConstant(bits)

---
inst: BitXor
is-primitive: yes
name: "bxor"
type: |
  ~% (tI @-> tI @-> tI)

params:
- numl : int
- numr : int
code: |
  IntegerConstant(numl lxor numr)

---
inst: BitAnd
is-primitive: yes
name: "band"
type: |
  ~% (tI @-> tI @-> tI)

params:
- numl : int
- numr : int
code: |
  IntegerConstant(numl land numr)

---
inst: BitOr
is-primitive: yes
name: "bor"
type: |
  ~% (tI @-> tI @-> tI)

params:
- numl : int
- numr : int
code: |
  IntegerConstant(numl lor numr)

---
inst: BitNot
is-primitive: yes
name: "bnot"
type: |
  ~% (tI @-> tI)

params:
- num : int
code: |
  IntegerConstant(lnot num)

---
inst: FloatPlus
is-primitive: yes
name: "+."
type: |
  ~% (tFL @-> tFL @-> tFL)

params:
- flt1 : float
- flt2 : float
code: |
  FloatConstant(flt1 +. flt2)

---
inst: FloatMinus
is-primitive: yes
name: "-."
type: |
  ~% (tFL @-> tFL @-> tFL)

params:
- flt1 : float
- flt2 : float
code: |
  FloatConstant(flt1 -. flt2)

---
inst: FloatTimes
is-primitive: yes
name: "*."
type: |
  ~% (tFL @-> tFL @-> tFL)

params:
- flt1 : float
- flt2 : float
code: |
  FloatConstant(flt1 *. flt2)

---
inst: FloatDivides
is-primitive: yes
name: "/."
type: |
  ~% (tFL @-> tFL @-> tFL)

params:
- flt1 : float
- flt2 : float
code: |
  FloatConstant(flt1 /. flt2)

---
inst: FloatSine
is-primitive: yes
name: "sin"
type: |
  ~% (tFL @-> tFL)

params:
- flt1 : float
code: |
  FloatConstant(sin flt1)

---
inst: FloatArcSine
is-primitive: yes
name: "asin"
type: |
  ~% (tFL @-> tFL)

params:
- flt1 : float
code: |
  FloatConstant(asin flt1)

---
inst: FloatCosine
is-primitive: yes
name: "cos"
type: |
  ~% (tFL @-> tFL)

params:
- flt1 : float
code: |
  FloatConstant(cos flt1)

---
inst: FloatArcCosine
is-primitive: yes
name: "acos"
type: |
  ~% (tFL @-> tFL)

params:
- flt1 : float
code: |
  FloatConstant(acos flt1)

---
inst: FloatTangent
is-primitive: yes
name: "tan"
type: |
  ~% (tFL @-> tFL)

params:
- flt1 : float
code: |
  FloatConstant(tan flt1)

---
inst: FloatArcTangent
is-primitive: yes
name: "atan"
type: |
  ~% (tFL @-> tFL)

params:
- flt1 : float
code: |
  FloatConstant(atan flt1)

---
inst: FloatArcTangent2
is-primitive: yes
name: "atan2"
type: |
  ~% (tFL @-> tFL @-> tFL)

params:
- flt1 : float
- flt2 : float
code: |
  FloatConstant(atan2 flt1 flt2)

---
inst: LengthPlus
is-primitive: yes
name: "+'"
type: |
  ~% (tLN @-> tLN @-> tLN)

params:
- len1 : length
- len2 : length
code: |
  LengthConstant(HorzBox.(len1 +% len2))

---
inst: LengthMinus
is-primitive: yes
name: "-'"
type: |
  ~% (tLN @-> tLN @-> tLN)

params:
- len1 : length
- len2 : length
code: |
  LengthConstant(HorzBox.(len1 -% len2))

---
inst: LengthTimes
is-primitive: yes
name: "*'"
type: |
  ~% (tLN @-> tFL @-> tLN)

params:
- len1 : length
- flt2 : float
code: |
  LengthConstant(HorzBox.(len1 *% flt2))

---
inst: LengthDivides
is-primitive: yes
name: "/'"
type: |
  ~% (tLN @-> tLN @-> tFL)

params:
- len1 : length
- len2 : length
code: |
  FloatConstant(HorzBox.(len1 /% len2))

---
inst: LengthLessThan
is-primitive: yes
name: "<'"
type: |
  ~% (tLN @-> tLN @-> tB)

params:
- len1 : length
- len2 : length
code: |
  BooleanConstant(HorzBox.(len1 <% len2))

---
inst: LengthGreaterThan
is-primitive: yes
name: ">'"
type: |
  ~% (tLN @-> tLN @-> tB)

params:
- len1 : length
- len2 : length
code: |
  BooleanConstant(HorzBox.(len2 <% len1))

---
inst: InsertArgs
fields:
- lst : syntactic_value list
params:
- func
code : |
  exec (func :: (List.rev_append lst stack)) env code dump

---
inst: PrimitiveSetEveryWordBreak
is-primitive : yes
name: "set-every-word-break"
type: |
  ~% (tIB @-> tIB @-> tCTX @-> tCTX)

params:
- hblst1 : horz
- hblst2 : horz
- (ctx, valuecmd) : context
code: |
  Context(HorzBox.({ ctx with
    before_word_break = hblst1;
    after_word_break = hblst2;
  }), valuecmd)

---
inst: BackendProbeCrossReference
is-primitive : yes
name: "probe-cross-reference"
type: |
  ~% (tS @-> (tOPT tS))

params:
- k : string
code: |
  match CrossRef.probe k with
  | None    -> Constructor("None", UnitConstant)
  | Some(v) -> Constructor("Some", StringConstant(v))
