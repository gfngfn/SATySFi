# ---------------------------------------------------
#   SATySFi virtual machine instruction definitions
# ---------------------------------------------------
#
# This is formatted according to the YAML.
#
# This file is read by `gen_code.rb`.
# `gen_code.rb` generates OCaml source code and
# type declarations for
#
# * `types.cppo.ml`,
# * `primitives.cppo.ml`,
# * `ir.cppo.ml`,
# * `evaluator.cppo.ml`, and
# * `vm.cppo.ml`.
#
#
# To add a new primitive,
#   1. Add a new instruction definition to this file.
#      (`is-pdf-mode-primitive` or `is-text-mode-primitive` should be yes.)
#   2. Add a new entry to primitives.ml.
#
#
# inst:          Instruction name (essential)
# is-pdf-mode-primitive:  Primitive for generating PDFs or not (default: no)
# is-text-mode-primitive: Primitive for generating texts or not (default: no)
# needs-reducef: Use `reducef` for evaluating applications (default: no)
# suppress-pp:   Use a simple pritty printer (default: no)
# custom-pp:     Specify custom pritty printer
# no-ircode:     Suppress code generation for `ir.ml` (default: no)
# no-interp:     Suppress code generation for `evaluator.ml` (default: !`is-pdf-mode-primitive`)
# name:          Identifier for the primitive
# type:          Type expression for the primitive
# fields:        Field list (for `abstract_tree` type)
# params:        Paramater list
# code:          Instruction code
#   (note: If `is-pdf-mode-primitive` or `is-text-mode-primitive` is yes, code that pushes to stack and
#          go to next instruction will be automatically inserted.
#          (see `gen_code.rb`))
#
---
inst: Concat
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "^"
type: |
  ~% (tS @-> tS @-> tS)

params:
- s1 : string
- s2 : string
code: |
  make_string (s1 ^ s2)

---
inst: PrimitiveSetMathVariantToChar
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "set-math-variant-char"
type: |
  ~% (tMCCLS @-> tI @-> tI @-> tCTX @-> tCTX)

params:
- mccls : math_char_class
- cpfrom : int
- cpto : int
- (ctx, ctxsub) : context
code: |
  let uchfrom = Uchar.of_int cpfrom in
  let uchto = Uchar.of_int cpto in
  let mcclsmap = ctx.HorzBox.math_variant_char_map in
  Context(HorzBox.({ ctx with
    math_variant_char_map = mcclsmap |> MathVariantCharMap.add (uchfrom, mccls) uchto;
  }), ctxsub)

---
inst: PrimitiveConvertStringForMath
is-pdf-mode-primitive: yes
name: "convert-string-for-math"
type: |
  ~% (tCTX @-> tMCCLS @-> tS @-> tS)

params:
- (ctx, ctxsub) : context
- mccls : math_char_class
- s : string
code:
  let ctx = HorzBox.({ ctx with math_char_class = mccls; }) in
  let (_, uchlst) = MathContext.convert_math_variant_char (ctx, ctxsub) s in
  make_string (InternalText.to_utf8 (InternalText.of_uchar_list uchlst))

---
inst: PrimitiveSetMathCommand
is-pdf-mode-primitive: yes
needs-reducef: yes
name: "set-math-command"
type: |
  ~% (tCMD @-> tCTX @-> tCTX)

params:
- valuecmd
- (ctx, ctxsub) : context
code: |
  let mcmd = get_math_command_func reducef valuecmd in
  Context(ctx, { ctxsub with math_command = mcmd; })

---
inst: BackendMathVariantCharDirect
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-variant-char"
type: |
  ~% (tMATHCLS @-> tMCSTY @-> tMATH)

params:
- mathcls : math_class
- valuercd
code: |
  let is_big = false in  (* temporary *)
  let mvsty = get_math_variant_style valuercd in
  MathValue(HorzBox.([MathPure(MathVariantCharDirect(mathcls, is_big, mvsty))]))

---
inst: BackendGetLeftMathClass
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "get-left-math-class"
type: |
  ~% (tCTX @-> tMATH @-> tOPT tMATHCLS)

params:
- ictx : context
- mathlst : math
code: |
  match mathlst with
  | [] ->
      Constructor("None", const_unit)

  | math :: _ ->
      let mathcls = Math.get_left_math_kind ictx math in
      make_math_class_option_value mathcls

---
inst: BackendGetRightMathClass
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "get-right-math-class"
type: |
  ~% (tCTX @-> tMATH @-> tOPT tMATHCLS)

params:
- ictx : context
- mathlst : math
code: |
  match List.rev mathlst with
  | [] ->
      Constructor("None", const_unit)

  | math :: _ ->
      let mathcls = Math.get_right_math_kind ictx math in
      make_math_class_option_value mathcls

---
inst: BackendSpaceBetweenMaths
is-pdf-mode-primitive: yes
name: "space-between-maths"
type: |
  ~% (tCTX @-> tMATH @-> tMATH @-> tOPT tIB)

params:
- ictx : context
- mathlst1 : math
- mathlst2 : math
code: |
  let mathctx = MathContext.make ictx in
  let hbspaceopt = Math.space_between_maths mathctx mathlst1 mathlst2 in
  match hbspaceopt with
  | None          -> Constructor("None", const_unit)
  | Some(hbspace) -> Constructor("Some", make_horz [hbspace])

---
inst: BackendMathConcat
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-concat"
type: |
  ~% (tMATH @-> tMATH @-> tMATH)

params:
- mlst1 : math
- mlst2 : math
code: |
  MathValue(List.append mlst1 mlst2)

---
inst: BackendMathGroup
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-group"
type: |
  ~% (tMATHCLS @-> tMATHCLS @-> tMATH @-> tMATH)

params:
- mathcls1 : math_class
- mathcls2 : math_class
- mlst : math
code: |
  MathValue([MathGroup(mathcls1, mathcls2, mlst)])

---
inst: BackendMathSuperscript
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-sup"
type: |
  ~% (tMATH @-> tMATH @-> tMATH)

params:
- mlst1 : math
- mlst2 : math
code: |
  MathValue([MathSuperscript(mlst1, mlst2)])

---
inst: BackendMathSubscript
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-sub"
type: |
  ~% (tMATH @-> tMATH @-> tMATH)

params:
- mlst1 : math
- mlst2 : math
code: |
  MathValue([MathSubscript(mlst1, mlst2)])

---
inst: BackendMathFraction
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-frac"
type: |
  ~% (tMATH @-> tMATH @-> tMATH)

params:
- mlst1 : math
- mlst2 : math
code: |
  MathValue([MathFraction(mlst1, mlst2)])

---
inst: BackendMathRadical
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-radical"
type: |
  ~% (tOPT tMATH @-> tMATH @-> tMATH)

params:
- value1mopt
- mlst2 : math
code: |
  let mlst1opt = get_option get_math value1mopt in
  let radical = Primitives.default_radical in  (* temporary; should be variable *)
  match mlst1opt with
  | None        -> MathValue([MathRadical(radical, mlst2)])
  | Some(mlst1) -> MathValue([MathRadicalWithDegree(mlst1, mlst2)])

---
inst: BackendMathParen
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-paren"
type: |
  ~% (tPAREN @-> tPAREN @-> tMATH @-> tMATH)

needs-reducef: yes
params:
- valueparenL
- valueparenR
- mlst1 : math
code: |
  let parenL = make_paren reducef valueparenL in
  let parenR = make_paren reducef valueparenR in
  MathValue([MathParen(parenL, parenR, mlst1)])

---
inst: BackendMathParenWithMiddle
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-paren-with-middle"
type: |
  ~% (tPAREN @-> tPAREN @-> tPAREN @-> tL tMATH @-> tMATH)

needs-reducef: yes
params:
- valueparenL
- valueparenR
- valuemiddle
- mlstlst : math_list
code: |
  let parenL = make_paren reducef valueparenL in
  let parenR = make_paren reducef valueparenR in
  let middle = make_paren reducef valuemiddle in
  MathValue([MathParenWithMiddle(parenL, parenR, middle, mlstlst)])

---
inst: BackendMathUpperLimit
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-upper"
type: |
  ~% (tMATH @-> tMATH @-> tMATH)

params:
- mlst1 : math
- mlst2 : math
code: |
  MathValue([MathUpperLimit(mlst1, mlst2)])

---
inst: BackendMathLowerLimit
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-lower"
type: |
  ~% (tMATH @-> tMATH @-> tMATH)

params:
- mlst1 : math
- mlst2 : math
code: |
  MathValue([MathLowerLimit(mlst1, mlst2)])

---
inst: BackendMathPullInScripts
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-pull-in-scripts"
type: |
  ~% (tMATHCLS @-> tMATHCLS @-> (tOPT tMATH @-> tOPT tMATH @-> tMATH) @-> tMATH)

params:
- mathcls1 : math_class
- mathcls2 : math_class
- valuef
needs-reducef: yes
code: |
  let mlstf = make_pull_in_scripts reducef valuef in
  let mlst = [HorzBox.(MathPullInScripts(mathcls1, mathcls2, mlstf))] in
  MathValue(mlst)

---
inst: BackendMathChar
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-char"
type: |
  ~% (tMATHCLS @-> tS @-> tMATH)

params:
- mathcls : math_class
- uchlst : uchar_list
code: |
  let mlst = [HorzBox.(MathPure(MathElement(mathcls, MathChar(false, uchlst))))] in
  MathValue(mlst)

---
inst: BackendMathBigChar
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-big-char"
type: |
  ~% (tMATHCLS @-> tS @-> tMATH)

params:
- mathcls : math_class
- uchlst : uchar_list
code: |
  let mlst = [HorzBox.(MathPure(MathElement(mathcls, MathChar(true, uchlst))))] in
  MathValue(mlst)

---
inst: BackendMathCharWithKern
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-char-with-kern"
type: |
  let mckf = tLN @-> tLN @-> tLN in
    ~% (tMATHCLS @-> tS @-> mckf @-> mckf @-> tMATH)

needs-reducef: yes
params:
- mathcls : math_class
- uchlst : uchar_list
- valuekernfL
- valuekernfR
code: |
  let kernfL = make_math_char_kern_func reducef valuekernfL in
  let kernfR = make_math_char_kern_func reducef valuekernfR in
  let mlst = [HorzBox.(MathPure(MathElement(mathcls, MathCharWithKern(false, uchlst, kernfL, kernfR))))] in
  MathValue(mlst)

---
inst: BackendMathBigCharWithKern
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-big-char-with-kern"
type: |
  let mckf = tLN @-> tLN @-> tLN in
    ~% (tMATHCLS @-> tS @-> mckf @-> mckf @-> tMATH)

needs-reducef: yes
params:
- mathcls : math_class
- uchlst : uchar_list
- valuekernfL
- valuekernfR
code: |
  let kernfL = make_math_char_kern_func reducef valuekernfL in
  let kernfR = make_math_char_kern_func reducef valuekernfR in
  let mlst = [HorzBox.(MathPure(MathElement(mathcls, MathCharWithKern(true, uchlst, kernfL, kernfR))))] in
  MathValue(mlst)

---
inst: BackendMathText
is-pdf-mode-primitive: yes
name: "text-in-math"
type: |
  ~% (tMATHCLS @-> (tCTX @-> tIB) @-> tMATH)

needs-reducef: yes
params:
- mathcls : math_class
- valuef
code: |
  let hblstf ictx =
    let valueh = reducef valuef [Context(ictx)] in
    get_horz valueh
  in
  MathValue(HorzBox.([MathPure(MathElement(mathcls, MathEmbeddedText(hblstf)))]))

---
inst: BackendMathColor
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-color"
type: |
  ~% (tCLR @-> tMATH @-> tMATH)

params:
- color : color
- mlst : math
code: |
  MathValue(HorzBox.([MathChangeContext(MathChangeColor(color), mlst)]))

---
inst: BackendMathCharClass
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "math-char-class"
type: |
  ~% (tMCCLS @-> tMATH @-> tMATH)

params:
- mccls : math_char_class
- mlst : math
code: |
  MathValue(HorzBox.([MathChangeContext(MathChangeMathCharClass(mccls), mlst)]))

---
inst: BackendEmbeddedMath
is-pdf-mode-primitive: yes
name: "embed-math"
type: |
  ~% (tCTX @-> tMATH @-> tIB)

params:
- ictx : context
- mlst : math
code: |
  let mathctx = MathContext.make ictx in
  let hblst = Math.main mathctx mlst in
  make_horz hblst

---
inst: BackendTabular
is-pdf-mode-primitive: yes
name: "tabular"
type: |
  ~% ((tL (tL tCELL)) @-> tRULESF @-> tIB)

needs-reducef : yes
params:
- valuetabular
- valuerulesf
code: |
  let tabular = get_list (get_list get_cell) valuetabular in
  let (imtabular, widlst, lenlst, wid, hgt, dpt) = Tabular.main tabular in
  let rulesf xs ys =
    let valuexs = make_length_list xs in
    let valueys = make_length_list ys in
    let valueret = reducef valuerulesf [valuexs; valueys] in
    graphics_of_list valueret
  in
  make_horz (HorzBox.([HorzPure(PHGFixedTabular(wid, hgt, dpt, imtabular, widlst, lenlst, rulesf))]))

---
inst: BackendRegisterPdfImage
is-pdf-mode-primitive: yes
name: "load-pdf-image"
type: |
  ~% (tS @-> tI @-> tIMG)

params:
- relpathstr : string
- pageno : int
code: |
  let abspath = MyUtil.make_abs_path (Filename.concat (OptionState.job_directory ()) relpathstr) in
  let imgkey = ImageInfo.add_pdf abspath pageno in
  make_image_key imgkey

---
inst: BackendRegisterOtherImage
is-pdf-mode-primitive: yes
name: "load-image"
type: |
  ~% (tS @-> tIMG)

params:
- relpath : string
code: |
  let abspath = MyUtil.make_abs_path (Filename.concat (OptionState.job_directory ()) relpath) in
  let imgkey = ImageInfo.add_image abspath in
  make_image_key imgkey

---
inst: BackendUseImageByWidth
is-pdf-mode-primitive: yes
name: "use-image-by-width"
type: |
  ~% (tIMG @-> tLN @-> tIB)

params:
- valueimg
- wid : length
code: |
  match valueimg with
  | BaseConstant(BCImageKey(imgkey)) ->
      let hgt = ImageInfo.get_height_from_width imgkey wid in
      make_horz (HorzBox.([HorzPure(PHGFixedImage(wid, hgt, imgkey))]))

  | _ ->
      report_bug_vm "BackendUseImage"

---
inst: BackendHookPageBreak
is-pdf-mode-primitive: yes
name: "hook-page-break"
type: |
  ~% ((tPBINFO @-> tPT @-> tU) @-> tIB)

needs-reducef: yes
params:
- hookf
code: |
  let hookf = make_hook reducef hookf in
  make_horz (HorzBox.([HorzPure(PHGHookPageBreak(hookf))]))

---
inst: PathUnite
is-pdf-mode-primitive: yes
name: "unite-path"
type: |
  ~% (tPATH @-> tPATH @-> tPATH)

params:
- pathlst1 : path_value
- pathlst2 : path_value
code: |
  make_path (List.append pathlst1 pathlst2)

---
inst: PathShift
is-pdf-mode-primitive: yes
name: "shift-path"
type: |
  ~% (tPT @-> tPATH @-> tPATH)

params:
- ptshift : point
- pathlst : path_value
code: |
  make_path (List.map (shift_path ptshift) pathlst)

---
inst: PathGetBoundingBox
is-pdf-mode-primitive: yes
name: "get-path-bbox"
type: |
  ~% (tPATH @-> tPROD [tPT; tPT])

params:
- pathlst : path_value
code: |
  let (ptmin, ptmax) = get_path_list_bbox pathlst in
  let value1 = make_point_value ptmin in
  let value2 = make_point_value ptmax in
  Tuple([value1; value2])

---
inst: PrePathBeginning
is-pdf-mode-primitive: yes
name: "start-path"
type: |
  ~% (tPT @-> tPRP)

params:
- pt0 : point
code: |
  make_prepath (PrePath.start pt0)

---
inst: PrePathLineTo
is-pdf-mode-primitive: yes
name: "line-to"
type: |
  ~% (tPT @-> tPRP @-> tPRP)

params:
- pt1 : point
- prepath : prepath
code: |
  make_prepath (prepath |> PrePath.line_to pt1)

---
inst: PrePathCubicBezierTo
is-pdf-mode-primitive: yes
name: "bezier-to"
type: |
  ~% (tPT @-> tPT @-> tPT @-> tPRP @-> tPRP)

params:
- ptS : point
- ptT : point
- pt1 : point
- prepath: prepath
code: |
  make_prepath (prepath |> PrePath.bezier_to ptS ptT pt1)

---
inst: PrePathTerminate
is-pdf-mode-primitive: yes
name: "terminate-path"
type: |
  ~% (tPRP @-> tPATH)

params:
- prepath : prepath
code: |
  make_path ([prepath |> PrePath.terminate])

---
inst: PrePathCloseWithLine
is-pdf-mode-primitive: yes
name: "close-with-line"
type: |
  ~% (tPRP @-> tPATH)

params:
- prepath : prepath
code: |
  make_path ([prepath |> PrePath.close_with_line])

---
inst: PrePathCloseWithCubicBezier
is-pdf-mode-primitive: yes
name: "close-with-bezier"
type: |
  ~% (tPT @-> tPT @-> tPRP @-> tPATH)

params:
- ptS : point
- ptT : point
- prepath : prepath
code: |
  make_path ([prepath |> PrePath.close_with_bezier ptS ptT])

---
inst: HorzConcat
is-pdf-mode-primitive: yes
name: "++"
type: |
  ~% (tIB @-> tIB @-> tIB)

params:
- hblst1 : horz
- hblst2 : horz
code: |
  make_horz (List.append hblst1 hblst2)

---
inst: VertConcat
is-pdf-mode-primitive: yes
name: "+++"
type: |
  ~% (tBB @-> tBB @-> tBB)

params:
- vblst1 : vert
- vblst2 : vert
code: |
  make_vert (List.append vblst1 vblst2)

---
inst: HorzLex
is-pdf-mode-primitive: yes
name: "read-inline"
type: |
  ~% (tCTX @-> tIT @-> tIB)

separated: yes
params:
- valuectx
- value1
code: |
  match value1 with
  | CompiledInputHorzWithEnvironment(imihlst, envi) -> exec_pdf_mode_intermediate_input_horz envi valuectx imihlst
  | _                                               -> report_bug_vm "HorzLex"

code-interp: |
  match value1 with
  | InputHorzWithEnvironment(imihlst, envi) -> interpret_pdf_mode_intermediate_input_horz envi valuectx imihlst
  | _                                       -> report_bug_value "HorzLex" value1

---
inst: VertLex
is-pdf-mode-primitive: yes
name: "read-block"
type: |
  ~% (tCTX @-> tBT @-> tBB)

separated: yes
params:
- valuectx
- value1
code: |
  match value1 with
  | CompiledInputVertWithEnvironment(imivlst, envi) -> exec_pdf_mode_intermediate_input_vert envi valuectx imivlst
  | _                                               -> report_bug_vm "VertLex"

code-interp: |
  match value1 with
  | InputVertWithEnvironment(imivlst, envi) -> interpret_pdf_mode_intermediate_input_vert envi valuectx imivlst
  | _                                       -> report_bug_value "VertLex" value1

---
inst: TextHorzLex
is-text-mode-primitive: yes
name: "stringify-inline"
type: |
  ~% (tTCTX @-> tIT @-> tS)

separated: yes
params:
- valuetctx
- value1
code: |
  match value1 with
  | CompiledInputHorzWithEnvironment(imihlst, envi) -> exec_text_mode_intermediate_input_horz envi valuetctx imihlst
  | _                                               -> report_bug_vm "TextHorzLex"

code-interp: |
  match value1 with
  | InputHorzWithEnvironment(imihlst, envi) -> interpret_text_mode_intermediate_input_horz envi valuetctx imihlst
  | _                                       -> report_bug_value "TextHorzLex" value1

---
inst: TextVertLex
is-text-mode-primitive: yes
name: "stringify-block"
type: |
  ~% (tTCTX @-> tBT @-> tS)

separated: yes
params:
- valuetctx
- value1
code: |
  match value1 with
  | CompiledInputVertWithEnvironment(imivlst, envi) -> exec_text_mode_intermediate_input_vert envi valuetctx imivlst
  | _                                               -> report_bug_vm "TextVertLex"

code-interp: |
  match value1 with
  | InputVertWithEnvironment(imivlst, envi) -> interpret_text_mode_intermediate_input_vert envi valuetctx imivlst
  | _                                       -> report_bug_value "TextVertLex" value1

---
inst: TextDeepenIndent
is-text-mode-primitive: yes
name: "deepen-indent"
type: |
  ~% (tI @-> tTCTX @-> tTCTX)

params:
- i : int
- tctx : text_mode_context
code: |
  let tctx = tctx |> TextBackend.deepen_indent i in
  BaseConstant(BCTextModeContext(tctx))

---
inst: TextBreak
is-text-mode-primitive: yes
name: "break"
params:
- tctx : text_mode_context
type: |
  ~% (tTCTX @-> tS)

code: |
  let i = TextBackend.get_indent tctx in
  let s = "\n" ^ (String.make i ' ') in
  make_string s

---
inst: TextGetInitialTextModeContext
is-text-mode-primitive: yes
name: "get-initial-text-info"
params:
- value1
type: |
  ~% (tU @-> tTCTX)

code: |
  match value1 with
  | BaseConstant(BCUnit) ->
      let tctx = TextBackend.get_initial_text_mode_context () in
      BaseConstant(BCTextModeContext(tctx))

  | _ ->
      report_bug_value "TextGetInitialTextModeContext" value1

---
inst: PrimitiveEmbeddedVertBreakable
is-pdf-mode-primitive: yes
name: "embed-block-breakable"
type: |
  ~% (tCTX @-> tBB @-> tIB)

params:
- (ctx, _) : context
- vblst : vert
code: |
  let wid = ctx.HorzBox.paragraph_width in
  make_horz [HorzEmbeddedVertBreakable(wid, vblst)]

---
inst: BackendFont
is-pdf-mode-primitive: yes
params:
- abbrev : string
- size_ratio : float
- rising_ratio : float
code: |
  make_font_value (abbrev, size_ratio, rising_ratio)

---
inst: BackendLineBreaking
is-pdf-mode-primitive: yes
name: "line-break"
type: |
  ~% (tB @-> tB @-> tCTX @-> tIB @-> tBB)

params:
- is_breakable_top : bool
- is_breakable_bottom : bool
- (ctx,  _) : context
- hblst : horz
code: |
  let imvblst = HorzBox.(LineBreak.main is_breakable_top is_breakable_bottom ctx.paragraph_top ctx.paragraph_bottom ctx hblst) in
  make_vert imvblst

---
inst: BackendPageBreaking
is-pdf-mode-primitive: yes
name: "page-break"
type: |
  ~% (tPG @-> tPAGECONTF @-> tPAGEPARTSF @-> tBB @-> tDOC)

needs-reducef: yes
params:
- pagesize : page_size
- valuepagecontf
- valuepagepartsf
- vblst : vert
code: |
  let pagecontf = make_page_content_scheme_func reducef valuepagecontf in
  let pagepartsf = make_page_parts_scheme_func reducef valuepagepartsf in
  BaseConstant(BCDocument(pagesize, pagecontf, pagepartsf, vblst))

---
inst: BackendVertFrame
is-pdf-mode-primitive: yes
name: "block-frame-breakable"
type: |
  ~% (tCTX @-> tPADS @-> tDECOSET @-> (tCTX @-> tBB) @-> tBB)

needs-reducef : yes
params:
- (ctx, ctxsub) : context
- pads : paddings
- (valuedecoS, valuedecoH, valuedecoM, valuedecoT) : decoset
- valuek
code: |
  let valuectxsub =
    Context(HorzBox.({ ctx with
      paragraph_width = HorzBox.(ctx.paragraph_width -% pads.paddingL -% pads.paddingR);
    }), ctxsub)
  in
  let vblst =
    let valuev = reducef valuek [valuectxsub] in
    get_vert valuev
  in
  make_vert (HorzBox.([
    VertTopMargin(true, ctx.paragraph_top);
    VertFrame(pads,
                make_frame_deco reducef valuedecoS,
                make_frame_deco reducef valuedecoH,
                make_frame_deco reducef valuedecoM,
                make_frame_deco reducef valuedecoT,
                ctx.paragraph_width, vblst);
    VertBottomMargin(true, ctx.paragraph_bottom);
  ]))

---
inst: BackendAddFootnote
is-pdf-mode-primitive: yes
name: "add-footnote"
type: |
  ~% (tBB @-> tIB)

params:
- vblst : vert
code: |
  let imvblst = PageBreak.solidify vblst in
  make_horz (HorzBox.([HorzPure(PHGFootnote(imvblst))]))

---
inst: BackendEmbeddedVertTop
is-pdf-mode-primitive: yes
name: "embed-block-top"
type: |
  ~% (tCTX @-> tLN @-> (tCTX @-> tBB) @-> tIB)

needs-reducef : yes
params:
- (ctx, ctxsub) : context
- wid : length
- valuek
code: |
  let valuectxsub =
    Context(HorzBox.({ ctx with paragraph_width = wid; }), ctxsub)
  in
  let vblst =
    let valuev = reducef valuek [valuectxsub] in
    get_vert valuev
  in
  let imvblst = PageBreak.solidify vblst in
  let (hgt, dpt) = PageBreak.adjust_to_first_line imvblst in
  make_horz (HorzBox.([HorzPure(PHGEmbeddedVert(wid, hgt, dpt, imvblst))]))

---
inst: BackendVertSkip
is-pdf-mode-primitive: yes
name: "block-skip"
type: |
  ~% (tLN @-> tBB)

params:
- len : length
code: |
  make_vert (HorzBox.([VertFixedBreakable(len)]))

---
inst: BackendEmbeddedVertBottom
is-pdf-mode-primitive: yes
name: "embed-block-bottom"
type: |
  ~% (tCTX @-> tLN @-> (tCTX @-> tBB) @-> tIB)

needs-reducef : yes
params:
- (ctx, ctxsub) : context
- wid : length
- valuek
code: |
  let valuectxsub =
    Context(HorzBox.({ ctx with paragraph_width = wid; }), ctxsub)
  in
  let vblst =
    let valuev = reducef valuek [valuectxsub] in
      get_vert valuev
  in
  let imvblst = PageBreak.solidify vblst in
  let (hgt, dpt) = PageBreak.adjust_to_last_line imvblst in
  make_horz (HorzBox.([HorzPure(PHGEmbeddedVert(wid, hgt, dpt, imvblst))]))

---
inst: BackendLineStackTop
is-pdf-mode-primitive: yes
name: "line-stack-top"
type: |
  ~% ((tL tIB) @-> tIB)

params:
- valuehblstlst
code: |
  let hblstlst = get_list get_horz valuehblstlst in
  let (wid, vblst) = make_line_stack hblstlst in
  let imvblst = PageBreak.solidify vblst in
  let (hgt, dpt) = PageBreak.adjust_to_first_line imvblst in
  make_horz (HorzBox.([HorzPure(PHGEmbeddedVert(wid, hgt, dpt, imvblst))]))

---
inst: BackendLineStackBottom
is-pdf-mode-primitive: yes
name: "line-stack-bottom"
type: |
  ~% ((tL tIB) @-> tIB)

params:
- valuehblstlst
code: |
  let hblstlst = get_list get_horz valuehblstlst in
  let (wid, vblst) = make_line_stack hblstlst in
  let imvblst = PageBreak.solidify vblst in
  let (hgt, dpt) = PageBreak.adjust_to_last_line imvblst in
  make_horz (HorzBox.([HorzPure(PHGEmbeddedVert(wid, hgt, dpt, imvblst))]))

---
inst: PrimitiveGetInitialContext
is-pdf-mode-primitive: yes
needs-reducef: yes
name: "get-initial-context"
type: |
  ~% (tLN @-> tCMD @-> tCTX)

params:
- txtwid : length
- valuecmd
code: |
  let ctx = Primitives.get_pdf_mode_initial_context txtwid in
  let mcmd = get_math_command_func reducef valuecmd in
  let ctxsub =
    {
      math_command = mcmd;
      dummy = ();
    }
  in
  Context(ctx, ctxsub)

---
inst: PrimitiveSetHyphenMin
is-pdf-mode-primitive: yes
name: "set-hyphen-min"
type: |
  ~% (tI @-> tI @-> tCTX @-> tCTX)

params:
- lmin : int
- rmin : int
- (ctx, ctxsub) : context
code: |
  Context(HorzBox.({ ctx with
    left_hyphen_min = max 0 lmin;
    right_hyphen_min = max 0 rmin;
  }), ctxsub)

---
inst: PrimitiveSetMinGapOfLines
is-pdf-mode-primitive: yes
name: "set-min-gap-of-lines"
type: |
  ~% (tLN @-> tCTX @-> tCTX)

params:
- lengap : length
- (ctx, ctxsub) : context
code: |
  Context(HorzBox.({ ctx with
    min_gap_of_lines = Length.max Length.zero lengap;
  }), ctxsub)

---
inst: PrimitiveSetSpaceRatio
is-pdf-mode-primitive: yes
name: "set-space-ratio"
type: |
  ~% (tFL @-> tFL @-> tFL @-> tCTX @-> tCTX)

params:
- ratio_natural : float
- ratio_shrink : float
- ratio_stretch : float
- (ctx, ctxsub) : context
code: |
  Context(HorzBox.({ ctx with
    space_natural = max 0. ratio_natural;
    space_shrink  = max 0. ratio_shrink;
    space_stretch = max 0. ratio_stretch;
  }), ctxsub)

---
inst: PrimitiveSetSpaceRatioBetweenScripts
is-pdf-mode-primitive: yes
name: "set-space-ratio-between-scripts"
type: |
  ~% (tFL @-> tFL @-> tFL @-> tSCR @-> tSCR @-> tCTX @-> tCTX)

params:
- ratio_natural : float
- ratio_shrink : float
- ratio_stretch : float
- script1 : script
- script2 : script
- (ctx, ctxsub) : context
code: |
  Context(HorzBox.({ ctx with
    script_space_map =
      ctx.script_space_map |> CharBasis.ScriptSpaceMap.add
        (script1, script2)
        (max 0. ratio_natural, max 0. ratio_shrink, max 0. ratio_stretch)
  }), ctxsub)

---
inst: PrimitiveGetSpaceRatioBetweenScripts
is-pdf-mode-primitive: yes
name: "get-space-ratio-between-scripts"
type: |
  ~% (tCTX @-> tSCR @-> tSCR @-> tOPT (tPROD [tFL; tFL; tFL]))

params:
- (ctx, _) : context
- script1 : script
- script2 : script
code: |
  match ctx.script_space_map |> CharBasis.ScriptSpaceMap.find_opt (script1, script2) with
  | None ->
      Constructor("None", const_unit)

  | Some((r0, r1, r2)) ->
      Constructor("Some", Tuple([
        make_float r0;
        make_float r1;
        make_float r2;
      ]))

---
inst: PrimitiveSetParagraphMargin
is-pdf-mode-primitive: yes
name: "set-paragraph-margin"
type: |
  ~% (tLN @-> tLN @-> tCTX @-> tCTX)

params:
- lentop : length
- lenbottom : length
- (ctx, ctxsub) : context
code: |
  Context(HorzBox.({ ctx with
    paragraph_top    = lentop;
    paragraph_bottom = lenbottom;
  }), ctxsub)

---
inst: PrimitiveSetParagraphMinAscenderAndDescender
is-pdf-mode-primitive: yes
name: "set-min-paragraph-ascender-and-descender"
type: |
  ~% (tLN @-> tLN @-> tCTX @-> tCTX)

params:
- lenminasc : length
- lenmindesc : length
- (ctx, ctxsub) : context
code: |
  Context(HorzBox.({ ctx with
    min_first_line_ascender = lenminasc;
    min_last_line_descender = lenmindesc;
  }), ctxsub)

---
inst: PrimitiveSetFontSize
is-pdf-mode-primitive: yes
name: "set-font-size"
type: |
  ~% (tLN @-> tCTX @-> tCTX)

params:
- size : length
- (ctx, ctxsub) : context
code: |
  Context(HorzBox.({ ctx with font_size = size; }), ctxsub)

---
inst: PrimitiveGetFontSize
is-pdf-mode-primitive: yes
name: "get-font-size"
type: |
  ~% (tCTX @-> tLN)

params:
- (ctx, _) : context
code: |
  make_length (ctx.HorzBox.font_size)

---
inst: PrimitiveSetFont
is-pdf-mode-primitive: yes
name: "set-font"
type: |
  ~% (tSCR @-> tFONT @-> tCTX @-> tCTX)

params:
- script : script
- font_info : font
- (ctx, ctxsub) : context
code: |
  let font_scheme_new = HorzBox.(ctx.font_scheme |> CharBasis.ScriptSchemeMap.add script font_info) in
  Context(HorzBox.({ ctx with font_scheme = font_scheme_new; }), ctxsub)

---
inst: PrimitiveGetFont
is-pdf-mode-primitive: yes
name: "get-font"
type: |
  ~% (tSCR @-> tCTX @-> tFONT)

params:
- script : script
- (ctx, _) : context
code: |
  let fontwr = HorzBox.get_font_with_ratio ctx script in
  make_font_value fontwr

---
inst: PrimitiveSetMathFont
is-pdf-mode-primitive: yes
name: "set-math-font"
type: |
  ~% (tS @-> tCTX @-> tCTX)

params:
- mfabbrev : string
- (ctx, ctxsub) : context
code: |
  Context(HorzBox.({ ctx with math_font = mfabbrev; }), ctxsub)

---
inst: PrimitiveSetDominantWideScript
is-pdf-mode-primitive: yes
name: "set-dominant-wide-script"
type: |
  ~% (tSCR @-> tCTX @-> tCTX)

params:
- script: script
- (ctx, ctxsub) : context
code: |
  Context(HorzBox.({ ctx with dominant_wide_script = script; }), ctxsub)

---
inst: PrimitiveGetDominantWideScript
is-pdf-mode-primitive: yes
name: "get-dominant-wide-script"
type: |
  ~% (tCTX @-> tSCR)

params:
- (ctx, _) : context
code: |
  make_script_value ctx.HorzBox.dominant_wide_script

---
inst: PrimitiveSetDominantNarrowScript
is-pdf-mode-primitive: yes
name: "set-dominant-narrow-script"
type: |
  ~% (tSCR @-> tCTX @-> tCTX)

params:
- script : script
- (ctx, ctxsub) : context
code: |
  Context(HorzBox.({ ctx with dominant_narrow_script = script; }), ctxsub)

---
inst: PrimitiveGetDominantNarrowScript
is-pdf-mode-primitive: yes
name: "get-dominant-narrow-script"
type: |
  ~% (tCTX @-> tSCR)

params:
- (ctx, _) : context
code: |
  make_script_value ctx.HorzBox.dominant_narrow_script

---
inst: PrimitiveSetLangSys
is-pdf-mode-primitive: yes
name: "set-language"
type: |
  ~% (tSCR @-> tLANG @-> tCTX @-> tCTX)

params:
- script : script
- langsys : language_system
- (ctx, ctxsub) : context
code: |
  Context(HorzBox.({ ctx with
    langsys_scheme = ctx.langsys_scheme |> CharBasis.ScriptSchemeMap.add script langsys;
  }), ctxsub)

---
inst: PrimitiveGetLangSys
is-pdf-mode-primitive: yes
name: "get-language"
type: |
  ~% (tSCR @-> tCTX @-> tLANG)

params:
- script : script
- (ctx, _) : context
code: |
  let langsys = HorzBox.get_language_system ctx script in
  make_language_system_value langsys

---
inst: PrimitiveSetTextColor
is-pdf-mode-primitive: yes
name: "set-text-color"
type: |
  ~% (tCLR @-> tCTX @-> tCTX)

params:
- color : color
- (ctx, ctxsub) : context
code: |
  Context(HorzBox.({ ctx with text_color = color; }), ctxsub)

---
inst: PrimitiveGetTextColor
is-pdf-mode-primitive: yes
name: "get-text-color"
type: |
  ~% (tCTX @-> tCLR)

params:
- (ctx, _) : context
code: |
  let color = ctx.HorzBox.text_color in
  make_color_value color

---
inst: PrimitiveSetLeading
is-pdf-mode-primitive: yes
name: "set-leading"
type: |
  ~% (tLN @-> tCTX @-> tCTX)

params:
- len : length
- (ctx, ctxsub) : context
code: |
  Context(HorzBox.({ ctx with leading = len; }), ctxsub)

---
inst: PrimitiveGetTextWidth
is-pdf-mode-primitive: yes
name: "get-text-width"
type: |
  ~% (tCTX @-> tLN)

params:
- (ctx, _) : context
code: |
  make_length (ctx.HorzBox.paragraph_width)

---
inst: PrimitiveSetManualRising
is-pdf-mode-primitive: yes
name: "set-manual-rising"
type: |
  ~% (tLN @-> tCTX @-> tCTX)

params:
- rising : length
- (ctx, ctxsub) : context
code: |
  Context(HorzBox.({ ctx with manual_rising = rising; }), ctxsub)

---
inst: PrimitiveRaise
is-pdf-mode-primitive: yes
name: "raise-inline"
type: |
  ~% (tLN @-> tIB @-> tIB)

params:
- rising : length
- hblst : horz
code: |
  make_horz (HorzBox.([HorzPure(PHGRising(rising, hblst))]))

---
inst: PrimitiveSetHyphenPenalty
is-pdf-mode-primitive: yes
name: "set-hyphen-penalty"
type: |
  ~% (tI @-> tCTX @-> tCTX)

params:
- pnlty : int
- (ctx, ctxsub) : context
code: |
  Context(HorzBox.({ ctx with hyphen_badness = pnlty; }), ctxsub)

---
inst: PrimitiveEmbed
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "embed-string"
type: |
  ~% (tS @-> tIT)

separated: yes
params:
- str : string
code: |
  CompiledInputHorzWithEnvironment([CompiledImInputHorzText(str)], env)

code-interp: |
  InputHorzWithEnvironment([ImInputHorzText(str)], env)

---
inst: PrimitiveExtract
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "extract-string"
type: |
  ~% (tIB @-> tS)
params:
  - hblst : horz
code: |
  make_string (HorzBox.extract_string hblst)

---
inst: PrimitiveGetAxisHeight
is-pdf-mode-primitive: yes
name: "get-axis-height"
type: |
  ~% (tCTX @-> tLN)

params:
- (ctx, _) : context
code: |
  let fontsize = ctx.HorzBox.font_size in
  let mfabbrev = ctx.HorzBox.math_font in
  let hgt = FontInfo.get_axis_height mfabbrev fontsize in
    make_length (hgt)

---
inst: BackendFixedEmpty
is-pdf-mode-primitive: yes
name: "inline-skip"
type: |
  ~% (tLN @-> tIB)

params:
- wid : length
code: |
  make_horz [HorzBox.HorzPure(HorzBox.PHSFixedEmpty(wid))]

---
inst: BackendOuterEmpty
is-pdf-mode-primitive: yes
name: "inline-glue"
type: |
  ~% (tLN @-> tLN @-> tLN @-> tIB)

params:
- widnat : length
- widshrink : length
- widstretch : length
code: |
  make_horz [HorzBox.HorzPure(HorzBox.PHSOuterEmpty(widnat, widshrink, widstretch))]

---
inst: BackendOuterFrame
is-pdf-mode-primitive: yes
name: "inline-frame-outer"
type: |
  ~% (tPADS @-> tDECO @-> tIB @-> tIB)

needs-reducef: yes
params:
- pads : paddings
- valuedeco
- hblst : horz
code: |
  make_horz ([HorzBox.HorzPure(HorzBox.PHGOuterFrame(
    pads,
    make_frame_deco reducef valuedeco,
    hblst))])

---
inst: BackendInnerFrame
is-pdf-mode-primitive: yes
name: "inline-frame-inner"
type: |
  ~% (tPADS @-> tDECO @-> tIB @-> tIB)

needs-reducef: yes
params:
- pads : paddings
- valuedeco
- hblst : horz
code: |
  make_horz ([HorzBox.HorzPure(HorzBox.PHGInnerFrame(
    pads,
    make_frame_deco reducef valuedeco,
    hblst))])

---
inst: BackendFixedFrame
is-pdf-mode-primitive: yes
name: "inline-frame-fixed"
type: |
  ~% (tLN @-> tPADS @-> tDECO @-> tIB @-> tIB)

needs-reducef: yes
params:
- wid : length
- pads : paddings
- valuedeco
- hblst : horz
code: |
  make_horz ([HorzBox.HorzPure(HorzBox.PHGFixedFrame(
    pads, wid,
    make_frame_deco reducef valuedeco,
    hblst))])

---
inst: BackendOuterFrameBreakable
is-pdf-mode-primitive: yes
name: "inline-frame-breakable"
type: |
  ~% (tPADS @-> tDECOSET @-> tIB @-> tIB)

needs-reducef: yes
params:
- pads : paddings
- (valuedecoS, valuedecoH, valuedecoM, valuedecoT) : decoset
- hblst : horz
code: |
  make_horz ([HorzBox.HorzFrameBreakable(
    pads, Length.zero, Length.zero,
    make_frame_deco reducef valuedecoS,
    make_frame_deco reducef valuedecoH,
    make_frame_deco reducef valuedecoM,
    make_frame_deco reducef valuedecoT,
    hblst
  )])

---
inst: BackendInlineGraphics
is-pdf-mode-primitive: yes
name: "inline-graphics"
type: |
  ~% (tLN @-> tLN @-> tLN @-> tIGR @-> tIB)

needs-reducef: yes
params:
- wid : length
- hgt : length
- dpt : length
- valueg
code: |
  let graphics = make_inline_graphics reducef valueg in
  make_horz (HorzBox.([HorzPure(PHGFixedGraphics(wid, hgt, Length.negate dpt, graphics))]))

---
inst: BackendInlineGraphicsOuter
is-pdf-mode-primitive: yes
name: "inline-graphics-outer"
type: |
  ~% (tLN @-> tLN @-> tIGRO @-> tIB)

needs-reducef: yes
params:
- hgt : length
- dpt : length
- valueg
code: |
  let graphics = make_inline_graphics_outer reducef valueg in
  make_horz (HorzBox.([HorzPure(PHGOuterFilGraphics(hgt, Length.negate dpt, graphics))]))

---
inst: BackendScriptGuard
is-pdf-mode-primitive: yes
name: "script-guard"
type: |
  ~% (tSCR @-> tIB @-> tIB)

params:
- script : script
- hblst : horz
code: |
  make_horz (HorzBox.([HorzScriptGuard(script, script, hblst)]))

---
inst: BackendScriptGuardBoth
is-pdf-mode-primitive: yes
name: "script-guard-both"
type: |
  ~% (tSCR @-> tSCR @-> tIB @-> tIB)

params:
- scriptL : script
- scriptR : script
- hblst : horz
code: |
  make_horz (HorzBox.([HorzScriptGuard(scriptL, scriptR, hblst)]))

---
inst: BackendGetLeftmostScript
is-pdf-mode-primitive: yes
name: "get-leftmost-script"
type: |
  ~% (tIB @-> tOPT tSCR)

params:
- hblst : horz
code: |
  let scriptopt = LineBreak.get_leftmost_script hblst in
  make_option make_script_value scriptopt

---
inst: BackendGetRightmostScript
is-pdf-mode-primitive: yes
name: "get-rightmost-script"
type: |
  ~% (tIB @-> tOPT tSCR)

params:
- hblst : horz
code: |
  let scriptopt = LineBreak.get_rightmost_script hblst in
  make_option make_script_value scriptopt

---
inst: BackendDiscretionary
is-pdf-mode-primitive: yes
name: "discretionary"
type: |
  ~% (tI @-> tIB @-> tIB @-> tIB @-> tIB)

params:
- pb : int
- hblst0 : horz
- hblst1 : horz
- hblst2 : horz
code: |
  make_horz (HorzBox.([HorzDiscretionary(pb, hblst0, hblst1, hblst2)]))

---
inst: BackendRegisterCrossReference
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "register-cross-reference"
type: |
  ~% (tS @-> tS @-> tU)

params:
- k : string
- v : string
code: |
  CrossRef.register k v;
  const_unit

---
inst: BackendGetCrossReference
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "get-cross-reference"
type: |
  ~% (tS @-> (tOPT tS))

params:
- k : string
code: |
  match CrossRef.get k with
  | None    -> Constructor("None", const_unit)
  | Some(v) -> Constructor("Some", make_string v)

---
inst: PrimitiveGetNaturalMetrics
is-pdf-mode-primitive: yes
name: "get-natural-metrics"
type: |
  ~% (tIB @-> tPROD [tLN; tLN; tLN])

params:
- hblst : horz
code: |
  let (wid, hgt, dpt) = LineBreak.get_natural_metrics hblst in
  Tuple([
    make_length (wid);
    make_length (hgt);
    make_length (Length.negate dpt);
  ])

---
inst: PrimitiveGetNaturalLength
is-pdf-mode-primitive: yes
name: "get-natural-length"
type: |
  ~% (tBB @-> tLN)

params:
- vblst : vert
code: |
  let imvblst = PageBreak.solidify vblst in
  let (hgt, dpt) = PageBreak.adjust_to_first_line imvblst in
  make_length (hgt +% (Length.negate dpt))

---
inst: PrimitiveDisplayMessage
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "display-message"
type: |
  ~% (tS @-> tU)

params:
- str : string
code: |
  print_endline str;
  const_unit

---
inst: PrimitiveListCons
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
params:
- valuehd
- valuetl
code: |
  match valuetl with
  | List(vlst) -> List(valuehd :: vlst)
  | _          -> report_bug_value "PrimitiveListCons" valuetl

---
inst: PrimitiveSame
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "string-same"
type: |
  ~% (tS @-> tS @-> tB)

params:
- str1 : string
- str2 : string
code: |
  make_bool (String.equal str1 str2)

---
inst: PrimitiveStringSub
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "string-sub"
type: |
  ~% (tS @-> tI @-> tI @-> tS)

params:
- str : string
- pos : int
- wid : int
code: |
  let resstr =
    try BatUTF8.sub str pos wid with
    | Invalid_argument(s) -> report_dynamic_error "illegal index for string-sub"
  in
  make_string resstr

---
inst: PrimitiveStringSubBytes
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "string-sub-bytes"
type: |
  ~% (tS @-> tI @-> tI @-> tS)

params:
- str : string
- pos : int
- wid : int
code: |
  let resstr =
    try String.sub str pos wid with
    | Invalid_argument(s) -> report_dynamic_error "illegal index for string-sub-bytes"
  in
  make_string resstr

---
inst: PrimitiveStringLength
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "string-length"
type: |
  ~% (tS @-> tI)

params:
- str : string
code: |
  make_int (BatUTF8.length str)

---
inst: PrimitiveStringByteLength
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "string-byte-length"
type: |
  ~% (tS @-> tI)

params:
- str : string
code: |
  make_int (String.length str)

---
inst: PrimitiveStringScan
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "string-scan"
type: |
  ~% (tRE @-> tS @-> tOPT (tPROD [tS; tS]))

params:
- pat : regexp
- str : string
code: |
  if Str.string_match pat str 0 then
    let matched = Str.matched_string str in
    let start   = String.length matched in
    let rest    = String.sub str start (String.length str - start) in
    Constructor("Some", Tuple([make_string matched; make_string rest]))
  else
    Constructor("None", const_unit)

---
inst: PrimitiveStringUnexplode
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "string-unexplode"
type: |
  ~% ((tL tI) @-> tS)

params:
- valueilst
code: |
  let ilst = get_list get_int valueilst in
  let s = (List.map Uchar.of_int ilst) |> InternalText.of_uchar_list |> InternalText.to_utf8 in
  make_string s

---
inst: PrimitiveRegExpOfString
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "regexp-of-string"
type: |
  ~% (tS @-> tRE)

params:
- str : string
code: |
  let regexp =
    try Str.regexp str with
    | Failure(msg) -> report_dynamic_error ("regexp-of-string: " ^ msg)
  in
  make_regexp regexp

---
inst: PrimitiveStringMatch
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "string-match"
type: |
  ~% (tRE @-> tS @-> tB)

params:
- pat : regexp
- s : string
code: |
  make_bool (Str.string_match pat s 0)

---
inst: PrimitiveSplitIntoLines
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "split-into-lines"
type: |
  ~% (tS @-> (tL (tPROD [tI; tS])))

params:
- s : string
code: |
  let slst = String.split_on_char '\n' s in
  let pairlst = slst |> List.map chop_space_indent in
  pairlst |> make_list (fun (i, s) -> Tuple([make_int i; make_string s]))

---
inst: PrimitiveSplitOnRegExp
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "split-on-regexp"
type: |
  ~% (tRE @-> tS @-> (tL (tPROD [tI; tS])))

params:
- sep : regexp
- str : string
code: |
  let slst = Str.split sep str in
  let pairlst = slst |> List.map chop_space_indent in
  pairlst |> make_list (fun (i, s) -> Tuple([make_int i; make_string s]))

---
inst: PrimitiveArabic
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "arabic"
type: |
  ~% (tI @-> tS)

params:
- num : int
code: |
  make_string (string_of_int num)

---
inst: PrimitiveShowFloat
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "show-float"
type: |
  ~% (tFL @-> tS)

params:
- fl : float
code: |
  make_string (string_of_float fl)


---
inst: PrimitiveFloat
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "float"
type: |
  ~% (tI @-> tFL)

params:
- ic1 : int
code: |
  make_float (float_of_int ic1)

---
inst: PrimitiveRound
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "round"
type: |
  ~% (tFL @-> tI)

params:
- fc1 : float
code: |
  make_int (int_of_float fc1)

---
inst: PrimitiveDrawText
is-pdf-mode-primitive: yes
name: "draw-text"
type: |
  ~% (tPT @-> tIB @-> tGR)

params:
- pt : point
- hblst : horz
code: |
  let (imhblst, _, _) = LineBreak.natural hblst in
  let grelem = GraphicD.make_text pt imhblst in
  make_graphics grelem

---
inst: PrimitiveDrawStroke
is-pdf-mode-primitive: yes
name: "stroke"
type: |
  ~% (tLN @-> tCLR @-> tPATH @-> tGR)

params:
- wid : length
- color : color
- pathlst : path_value
code: |
  let grelem = GraphicD.make_stroke wid color pathlst in
  make_graphics grelem

---
inst: PrimitiveDrawFill
is-pdf-mode-primitive: yes
name: "fill"
type: |
  ~% (tCLR @-> tPATH @-> tGR)

params:
- color : color
- pathlst : path_value
code: |
  let grelem = GraphicD.make_fill color pathlst in
  make_graphics grelem

---
inst: PrimitiveDrawDashedStroke
is-pdf-mode-primitive: yes
name: "dashed-stroke"
type: |
  ~% (tLN @-> tDASH @-> tCLR @-> tPATH @-> tGR)

params:
- wid : length
- valuetup3
- color : color
- pathlst : path_value
code: |
  let (len1, len2, len3) = get_tuple3 get_length valuetup3 in
  let grelem = GraphicD.make_dashed_stroke wid (len1, len2, len3) color pathlst in
  make_graphics grelem

---
inst: PrimitiveShiftGraphics
is-pdf-mode-primitive: yes
name: "shift-graphics"
type: |
  ~% (tPT @-> tGR @-> tGR)

params:
- vec : point
- grelem : graphics_element
code: |
  make_graphics (GraphicD.shift_element vec grelem)

---
inst: PrimtiveGetGraphicsBBox
is-pdf-mode-primitive: yes
name: get-graphics-bbox
type: |
  ~% (tGR @-> tPROD [tPT; tPT])

params:
- grelem : graphics_element
code: |
  let (ptmin, ptmax) =
    GraphicD.get_element_bbox (fun (x, y) imhblst ->
      let (wid, hgt, dpt) = HorzBox.get_metrics_of_intermediate_horz_box_list imhblst in
        ((x, y +% dpt), (x +% wid, y +% hgt))
    ) grelem
  in
  let value1 = make_point_value ptmin in
  let value2 = make_point_value ptmax in
  Tuple([value1; value2])

---
inst: Times
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "*"
type: |
  ~% (tI @-> tI @-> tI)

params:
- numl : int
- numr : int
code: |
  make_int (numl * numr)

---
inst: Divides
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "/"
type: |
  ~% (tI @-> tI @-> tI)

params:
- numl : int
- numr : int
code: |
  try make_int (numl / numr) with
  | Division_by_zero -> report_dynamic_error "division by zero"

---
inst: Mod
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "mod"
type: |
  ~% (tI @-> tI @-> tI)

params:
- numl : int
- numr : int
code: |
  try make_int (numl mod numr) with
  | Division_by_zero -> report_dynamic_error "division by zero"

---
inst: Plus
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "+"
type: |
  ~% (tI @-> tI @-> tI)

params:
- numl : int
- numr : int
code: |
  make_int (numl + numr)

---
inst: Minus
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "-"
type: |
  ~% (tI @-> tI @-> tI)

params:
- numl : int
- numr : int
code: |
  make_int (numl - numr)

---
inst: EqualTo
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "=="
type: |
  ~% (tI @-> tI @-> tB)

params:
- numl : int
- numr : int
code: |
  make_bool (numl = numr)

---
inst: GreaterThan
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: ">"
type: |
  ~% (tI @-> tI @-> tB)

params:
- numl : int
- numr : int
code: |
  make_bool (numl > numr)

---
inst: LessThan
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "<"
type: |
  ~% (tI @-> tI @-> tB)

params:
- numl : int
- numr : int
code: |
  make_bool (numl < numr)

---
inst: LogicalAnd
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "&&"
type: |
  ~% (tB @-> tB @-> tB)

params:
- binl : bool
- binr : bool
code: |
  make_bool (binl && binr)

---
inst: LogicalOr
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "||"
type: |
  ~% (tB @-> tB @-> tB)

params:
- binl : bool
- binr : bool
code: |
  make_bool (binl || binr)

---
inst: LogicalNot
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "not"
type: |
  ~% (tB @-> tB)

params:
- binl : bool
code: |
  make_bool (not binl)

---
inst: FloatPlus
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "+."
type: |
  ~% (tFL @-> tFL @-> tFL)

params:
- flt1 : float
- flt2 : float
code: |
  make_float (flt1 +. flt2)

---
inst: FloatMinus
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "-."
type: |
  ~% (tFL @-> tFL @-> tFL)

params:
- flt1 : float
- flt2 : float
code: |
  make_float (flt1 -. flt2)

---
inst: FloatTimes
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "*."
type: |
  ~% (tFL @-> tFL @-> tFL)

params:
- flt1 : float
- flt2 : float
code: |
  make_float (flt1 *. flt2)

---
inst: FloatDivides
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "/."
type: |
  ~% (tFL @-> tFL @-> tFL)

params:
- flt1 : float
- flt2 : float
code: |
  make_float (flt1 /. flt2)

---
inst: FloatSine
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "sin"
type: |
  ~% (tFL @-> tFL)

params:
- flt1 : float
code: |
  make_float (sin flt1)

---
inst: FloatArcSine
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "asin"
type: |
  ~% (tFL @-> tFL)

params:
- flt1 : float
code: |
  make_float (asin flt1)

---
inst: FloatCosine
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "cos"
type: |
  ~% (tFL @-> tFL)

params:
- flt1 : float
code: |
  make_float (cos flt1)

---
inst: FloatArcCosine
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "acos"
type: |
  ~% (tFL @-> tFL)

params:
- flt1 : float
code: |
  make_float (acos flt1)

---
inst: FloatTangent
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "tan"
type: |
  ~% (tFL @-> tFL)

params:
- flt1 : float
code: |
  make_float (tan flt1)

---
inst: FloatArcTangent
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "atan"
type: |
  ~% (tFL @-> tFL)

params:
- flt1 : float
code: |
  make_float (atan flt1)

---
inst: FloatArcTangent2
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "atan2"
type: |
  ~% (tFL @-> tFL @-> tFL)

params:
- flt1 : float
- flt2 : float
code: |
  make_float (atan2 flt1 flt2)

---
inst: LengthPlus
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "+'"
type: |
  ~% (tLN @-> tLN @-> tLN)

params:
- len1 : length
- len2 : length
code: |
  make_length (HorzBox.(len1 +% len2))

---
inst: LengthMinus
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "-'"
type: |
  ~% (tLN @-> tLN @-> tLN)

params:
- len1 : length
- len2 : length
code: |
  make_length (HorzBox.(len1 -% len2))

---
inst: LengthTimes
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "*'"
type: |
  ~% (tLN @-> tFL @-> tLN)

params:
- len1 : length
- flt2 : float
code: |
  make_length (HorzBox.(len1 *% flt2))

---
inst: LengthDivides
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "/'"
type: |
  ~% (tLN @-> tLN @-> tFL)

params:
- len1 : length
- len2 : length
code: |
  make_float (HorzBox.(len1 /% len2))

---
inst: LengthLessThan
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: "<'"
type: |
  ~% (tLN @-> tLN @-> tB)

params:
- len1 : length
- len2 : length
code: |
  make_bool (HorzBox.(len1 <% len2))

---
inst: LengthGreaterThan
is-pdf-mode-primitive: yes
is-text-mode-primitive: yes
name: ">'"
type: |
  ~% (tLN @-> tLN @-> tB)

params:
- len1 : length
- len2 : length
code: |
  make_bool (HorzBox.(len2 <% len1))

---
inst: PrimitiveSetWordBreakPenalty
is-pdf-mode-primitive: yes
name: "set-word-break-penalty"
type: |
  ~% (tI @-> tCTX @-> tCTX)

params:
- pnlty : int
- (ctx, ctxsub) : context
code: |
  Context(HorzBox.{ ctx with
    space_badness = pnlty;
  }, ctxsub)

---
inst: PrimitiveSetEveryWordBreak
is-pdf-mode-primitive: yes
name: "set-every-word-break"
type: |
  ~% (tIB @-> tIB @-> tCTX @-> tCTX)

params:
- hblst1 : horz
- hblst2 : horz
- (ctx, ctxsub) : context
code: |
  Context(HorzBox.({ ctx with
    before_word_break = hblst1;
    after_word_break = hblst2;
  }), ctxsub)

---
inst: PrimitiveGetEveryWordBreak
is-pdf-mode-primitive: yes
name: "get-every-word-break"
type: |
  ~% (tCTX @-> tPROD [tIB; tIB])

params:
- (ctx, _) : context
code: |
  let hblst1 = ctx.HorzBox.before_word_break in
  let hblst2 = ctx.HorzBox.after_word_break in
  Tuple([make_horz hblst1; make_horz hblst2])

---
inst: BackendProbeCrossReference
is-pdf-mode-primitive : yes
name: "probe-cross-reference"
type: |
  ~% (tS @-> (tOPT tS))

params:
- k : string
code: |
  match CrossRef.probe k with
  | None    -> Constructor("None", const_unit)
  | Some(v) -> Constructor("Some", make_string v)

---
inst: BackendRegisterDestination
is-pdf-mode-primitive: yes
name: "register-destination"
type: |
  ~% (tS @-> tPT @-> tU)

params:
- name : string
- p : point

code: |
  NamedDest.register name p;
  const_unit

---
inst: BackendRegisterLinkToUri
is-pdf-mode-primitive: yes
name: "register-link-to-uri"
type: |
  ~% (tS @-> tPT @-> tLN @-> tLN @-> tLN @-> (tOPT (tPROD [tLN; tCLR])) @-> tU)

params:
- uri : string
- pt : point
- wid : length
- hgt : length
- dpt : length
- vborderopt

code: |
  let borderopt = get_option (get_pair get_length get_color) vborderopt in
  Annotation.register (Annotation.Link(Pdfaction.Uri(uri))) (pt, wid, hgt, dpt) borderopt;
  const_unit

---
inst: BackendRegisterLinkToLocation
is-pdf-mode-primitive: yes
name: "register-link-to-location"
type: |
  ~% (tS @-> tPT @-> tLN @-> tLN @-> tLN @-> (tOPT (tPROD [tLN; tCLR])) @-> tU)

params:
- name : string
- pt : point
- wid : length
- hgt : length
- dpt : length
- vborderopt

code: |
  let borderopt = get_option (get_pair get_length get_color) vborderopt in
  let destname = NamedDest.get name in
  Annotation.register (Annotation.Link(Pdfaction.GotoName(destname))) (pt, wid, hgt, dpt) borderopt;
  const_unit

---
inst: BackendRegisterOutline
is-pdf-mode-primitive : yes
name: "register-outline"
type: |
  ~% ((tL(tPROD [tI; tS; tS; tB])) @-> tU)
params:
  - ol
code: |
  Outline.register (get_list get_outline ol);
  const_unit
